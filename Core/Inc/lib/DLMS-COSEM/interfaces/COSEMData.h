// ===========================================================================
// Copyright (c) 2018, Electric Power Research Institute (EPRI)
// All rights reserved.
//
// DLMS-COSEM ("this software") is licensed under BSD 3-Clause license.
//
// Redistribution and use in source and binary forms, with or without modification,
// are permitted provided that the following conditions are met:
//
// *  Redistributions of source code must retain the above copyright notice, this
//    list of conditions and the following disclaimer.
//
// *  Redistributions in binary form must reproduce the above copyright notice,
//    this list of conditions and the following disclaimer in the documentation
//    and/or other materials provided with the distribution.
//
// *  Neither the name of EPRI nor the names of its contributors may
//    be used to endorse or promote products derived from this software without
//    specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
// IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
// INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
// WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
// OF SUCH DAMAGE.
//
// This EPRI software incorporates work covered by the following copyright and permission
// notices. You may not use these works except in compliance with their respective
// licenses, which are provided below.
//
// These works are provided by the copyright holders and contributors "as is" and any express or
// implied warranties, including, but not limited to, the implied warranties of merchantability
// and fitness for a particular purpose are disclaimed.
//
// This software relies on the following libraries and licenses:
//
// ###########################################################################
// Boost Software License, Version 1.0
// ###########################################################################
//
// * asio v1.10.8 (https://sourceforge.net/projects/asio/files/)
//
// Boost Software License - Version 1.0 - August 17th, 2003
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
//
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.
//

#pragma once

#include <cstdint>
#include <vector>
#include <stack>
#include <limits>

#include "DLMSValue.h"

namespace EPRI
{
    enum COSEMDataType : uint8_t
    {
        NULL_DATA            = 0,
        ARRAY                = 1,
        STRUCTURE            = 2,
        BOOLEAN              = 3,
        BIT_STRING           = 4,
        DOUBLE_LONG          = 5,
        DOUBLE_LONG_UNSIGNED = 6,
        FLOATING_POINT       = 7,
        OCTET_STRING         = 9,
        VISIBLE_STRING       = 10,
        UTF8_STRING          = 12,
        BCD                  = 13,
        INTEGER              = 15,
        LONG                 = 16,
        UNSIGNED             = 17,
        LONG_UNSIGNED        = 18,
        COMPACT_ARRAY        = 19,
        LONG64               = 20,
        LONG64_UNSIGNED      = 21,
        ENUM                 = 22,
        FLOAT32              = 23,
        FLOAT64              = 24,
        DATE_TIME            = 25,
        DATE                 = 26,
        TIME                 = 27,
        // ANY_DATA             = 254,
        DONT_CARE            = 255
    };

    typedef int32_t DOUBLE_LONG_CType;
    typedef uint32_t DOUBLE_LONG_UNSIGNED_CType;
    typedef DLMSVector OCTET_STRING_CType;
    typedef std::string VISIBLE_STRING_CType;
    typedef int8_t INTEGER_CType;
    typedef int16_t LONG_CType;
    typedef uint8_t UNSIGNED_CType;
    typedef uint16_t LONG_UNSIGNED_CType;
    typedef int64_t LONG64_CType;
    typedef uint64_t LONG64_UNSIGNED_CType;
    typedef DLMSBitSet BIT_STRING_CType;

    enum COSEMSchemaOptions : uint32_t
    {
        NO_OPTIONS  = 0x00000000
    };

    enum COSEMInternalDataType : uint32_t
    {
        NORMAL_T              = 0x00000000,
        BEGIN_SPECIAL_T       = 0x10000000,
        END_SPECIAL_T         = 0x20000000,
        BEGIN_SPECIAL_ENTRY_T = 0x30000000,
        END_SPECIAL_ENTRY_T   = 0x40000000,
        BEGIN_CHOICE_T        = 0x50000000,
        END_CHOICE_T          = 0x60000000,
        END_SCHEMA_T          = 0xF0000000
    };

    typedef uint32_t               ComponentOptionType;
    typedef uint32_t               SchemaBaseType;
    struct SchemaEntry
    {
        SchemaBaseType  m_SchemaType;
        DLMSValue     m_Extra;
    };
    typedef const SchemaEntry *    SchemaEntryPtr;
    typedef SchemaEntryPtr         SchemaType;

#define COSEM_SCHEMA_INTERNAL_DATA_TYPE(SCH)\
        ((SCH)->m_SchemaType & 0xF0000000)

#define COSEM_IS_SCHEMA_END(SCH)\
        (EPRI::COSEMInternalDataType::END_SCHEMA_T == COSEM_SCHEMA_INTERNAL_DATA_TYPE(SCH))

#define COSEM_IS_ARRAY_BEGIN(SCH)\
        (((EPRI::COSEMInternalDataType::BEGIN_SPECIAL_T | EPRI::COSEMDataType::ARRAY) & \
         (SCH)->m_SchemaType) == (EPRI::COSEMInternalDataType::BEGIN_SPECIAL_T | EPRI::COSEMDataType::ARRAY))

#define COSEM_IS_ARRAY_END(SCH)\
        (((EPRI::COSEMInternalDataType::END_SPECIAL_T | EPRI::COSEMDataType::ARRAY) & \
         (SCH)->m_SchemaType) == (EPRI::COSEMInternalDataType::END_SPECIAL_T | EPRI::COSEMDataType::ARRAY))

#define COSEM_IS_STRUCTURE_BEGIN(SCH)\
        (((EPRI::COSEMInternalDataType::BEGIN_SPECIAL_T | EPRI::COSEMDataType::STRUCTURE) & \
         (SCH)->m_SchemaType) == (EPRI::COSEMInternalDataType::BEGIN_SPECIAL_T | EPRI::COSEMDataType::STRUCTURE))

#define COSEM_IS_STRUCTURE_END(SCH)\
        (((EPRI::COSEMInternalDataType::END_SPECIAL_T | EPRI::COSEMDataType::STRUCTURE) & \
         (SCH)->m_SchemaType) == (EPRI::COSEMInternalDataType::END_SPECIAL_T | EPRI::COSEMDataType::STRUCTURE))

#define COSEM_IS_BEGINNING(SCH)\
        (\
            COSEM_SCHEMA_INTERNAL_DATA_TYPE(SCH) == EPRI::COSEMInternalDataType::BEGIN_SPECIAL_T ||\
            COSEM_SCHEMA_INTERNAL_DATA_TYPE(SCH) == EPRI::COSEMInternalDataType::BEGIN_SPECIAL_ENTRY_T ||\
            COSEM_SCHEMA_INTERNAL_DATA_TYPE(SCH) == EPRI::COSEMInternalDataType::BEGIN_CHOICE_T\
        )

#define COSEM_IS_ENDING(SCH)\
        (\
            COSEM_SCHEMA_INTERNAL_DATA_TYPE(SCH) == EPRI::COSEMInternalDataType::END_SPECIAL_T ||\
            COSEM_SCHEMA_INTERNAL_DATA_TYPE(SCH) == EPRI::COSEMInternalDataType::END_SPECIAL_ENTRY_T ||\
            COSEM_SCHEMA_INTERNAL_DATA_TYPE(SCH) == EPRI::COSEMInternalDataType::END_CHOICE_T\
        )

#define COSEM_SCHEMA_OPTIONS(SCH)\
        COSEMSchemaOptions((SCH)->m_SchemaType & 0x0F000000)

#define COSEM_SCHEMA_DATA_TYPE(SCH)\
        COSEMDataType((SCH)->m_SchemaType & 0x000000FF)

#define COSEM_SCHEMA_DATA_TYPE_SIZE(SCH)\
        size_t(((SCH)->m_SchemaType & 0x00FF0000) >> 16)

#define COSEM_DEFINE_SCHEMA(SDEF)\
        static const SchemaEntry SDEF[];

#define COSEM_BEGIN_SCHEMA(SDEF) \
        const SchemaEntry SDEF[] =\
        {
#define COSEM_BEGIN_ARRAY\
            { (EPRI::COSEMInternalDataType::BEGIN_SPECIAL_T | COSEMDataType::ARRAY) },
#define COSEM_END_ARRAY\
            { (EPRI::COSEMInternalDataType::END_SPECIAL_T | COSEMDataType::ARRAY) },
#define COSEM_BEGIN_STRUCTURE\
            { (EPRI::COSEMInternalDataType::BEGIN_SPECIAL_T | COSEMDataType::STRUCTURE) },
#define COSEM_END_STRUCTURE\
            { (EPRI::COSEMInternalDataType::END_SPECIAL_T | COSEMDataType::STRUCTURE) },
#define COSEM_BEGIN_COMPACT_ARRAY\
            { (EPRI::COSEMInternalDataType::BEGIN_SPECIAL_T | COSEMDataType::COMPACT_ARRAY) },
#define COSEM_END_COMPACT_ARRAY\
            { (EPRI::COSEMInternalDataType::END_SPECIAL_T | COSEMDataType::COMPACT_ARRAY) },
#define COSEM_BEGIN_CHOICE\
            { (EPRI::COSEMInternalDataType::BEGIN_CHOICE_T) },
#define COSEM_END_CHOICE\
            { (EPRI::COSEMInternalDataType::END_CHOICE_T) },
#define COSEM_NULL_DATA_TYPE\
            { EPRI::COSEMDataType::NULL_DATA },
#define COSEM_BOOLEAN_TYPE\
            { EPRI::COSEMDataType::BOOLEAN },
#define COSEM_BIT_STRING_TYPE(SIZE)\
            { EPRI::COSEMDataType::BIT_STRING | ((SIZE) << 16) },
#define COSEM_DOUBLE_LONG_TYPE\
            { EPRI::COSEMDataType::DOUBLE_LONG },
#define COSEM_DOUBLE_LONG_UNSIGNED_TYPE\
            { EPRI::COSEMDataType::DOUBLE_LONG_UNSIGNED },
#define COSEM_FLOATING_POINT_TYPE\
            { EPRI::COSEMDataType::FLOATING_POINT },
#define COSEM_OCTET_STRING_TYPE\
            { EPRI::COSEMDataType::OCTET_STRING },
#define COSEM_VISIBLE_STRING_TYPE\
            { EPRI::COSEMDataType::VISIBLE_STRING },
#define COSEM_UTF8_STRING_TYPE\
            { EPRI::COSEMDataType::UTF8_STRING },
#define COSEM_BCD_TYPE\
            { EPRI::COSEMDataType::BCD },
#define COSEM_INTEGER_TYPE\
            { EPRI::COSEMDataType::INTEGER },
#define COSEM_LONG_TYPE\
            { EPRI::COSEMDataType::LONG },
#define COSEM_UNSIGNED_TYPE\
            { EPRI::COSEMDataType::UNSIGNED },
#define COSEM_LONG_UNSIGNED_TYPE\
            { EPRI::COSEMDataType::LONG_UNSIGNED },
#define COSEM_LONG64_TYPE\
            { EPRI::COSEMDataType::LONG64 },
#define COSEM_LONG64_UNSIGNED_TYPE\
            { EPRI::COSEMDataType::LONG64_UNSIGNED },
#define COSEM_ENUM_TYPE(...)\
            { EPRI::COSEMDataType::ENUM, \
              DLMSValue(std::initializer_list<uint32_t>(__VA_ARGS__)) },
#define COSEM_FLOAT32_TYPE\
            { EPRI::COSEMDataType::FLOAT32 },
#define COSEM_FLOAT64_TYPE\
            { EPRI::COSEMDataType::FLOAT64 },
#define COSEM_DATE_TIME_TYPE\
            { EPRI::COSEMDataType::DATE_TIME },
#define COSEM_DATE_TYPE\
            { EPRI::COSEMDataType::DATE },
#define COSEM_TIME_TYPE\
            { EPRI::COSEMDataType::TIME },
#define COSEM_END_SCHEMA\
        };
    //
    // Standard Schema Definitions
    //
    extern const SchemaEntry OctetStringSchema[];
    extern const SchemaEntry LongSchema[];
    extern const SchemaEntry UnsignedSchema[];
    extern const SchemaEntry IntegerSchema[];
    extern const SchemaEntry BooleanSchema[];
    extern const SchemaEntry DoubleLongUnsignedSchema[];    // Himanshu
    extern const SchemaEntry Float32Schema[];    // Himanshu

    class COSEMBitString;

    class COSEMType
    {
        friend class COSEMBitString;

    public:
        COSEMType();
        COSEMType(SchemaEntryPtr Schema);
        COSEMType(SchemaBaseType DT, const DLMSValue& Value);
        virtual ~COSEMType();

        virtual void GetBytes(DLMSVector * pDestination) const;
        virtual std::vector<uint8_t> GetBytes() const;
        virtual bool Parse(DLMSVector * pData);
        virtual bool Parse(const DLMSVector& Data);

        virtual bool IsEmpty() const;
        virtual void Clear();
        virtual void Rewind();
        virtual bool SelectChoice(COSEMDataType Choice);
        virtual bool GetChoice(COSEMDataType * pChoice);
        virtual bool Append(const DLMSValue& Value);
        virtual bool Append();

        enum GetNextResult
        {
            VALUE_RETRIEVED = 0,
            END_OF_SCHEMA,
            NO_VALUE_FOUND,
            SCHEMA_MISMATCH,
            INVALID_STREAM,
            INVALID_CONDITION,
            VALUE_EMPTY
        };

        virtual GetNextResult GetNextValue(DLMSValue * pValue);

        inline COSEMDataType GetCurrentSchemaType() const
        {
            return COSEM_SCHEMA_DATA_TYPE(GetCurrentSchemaEntry());
        }
        inline COSEMSchemaOptions GetCurrentSchemaOptions() const
        {
            return COSEM_SCHEMA_OPTIONS(GetCurrentSchemaEntry());
        }
        inline size_t GetCurrentSchemaTypeSize() const
        {
            return COSEM_SCHEMA_DATA_TYPE_SIZE(GetCurrentSchemaEntry());
        }
        //
        // Operators
        //
        bool operator==(const std::vector<uint8_t>& rhs) const;
        bool operator==(const COSEMType& rhs) const;
        COSEMType& operator=(const DLMSVector& rhs);
        operator const DLMSVector&();

    protected:
        COSEMType(SchemaBaseType DT);
        void SetSchemaType(SchemaBaseType DT);

        inline SchemaEntryPtr GetCurrentSchemaEntry() const
        {
            return m_pCurrentSchema;
        }

        GetNextResult GetNextSchemaEntry(SchemaEntryPtr * ppSchemaEntry);

        bool InternalAppend(const DLMSValue& Value);
        bool InternalAppend(COSEMType * pValue);
        bool InternalSimpleAppend(SchemaEntryPtr SchemaEntry, const DLMSValue& Value);
        bool InternalAppend(const DLMSVector& Value);

        GetNextResult InternalSimpleGet(SchemaEntryPtr SchemaEntry, DLMSValue * pValue);
        ssize_t StructureElementCount(SchemaEntryPtr pSchemaEntry) const;

        const COSEMDataType      INVALID_CHOICE = COSEMDataType::DONT_CARE;
        enum ParseStates
        {
            ST_SIMPLE,
            ST_CHOICE,
            ST_STRUCTURE,
            ST_ARRAY
        };
        struct ParseState
        {
            ParseState(SchemaEntryPtr SchemaEntry,
                ParseStates State,
                COSEMDataType Choice)
                : m_SchemaEntry(SchemaEntry)
                , m_State(State)
                , m_Choice(Choice)
            {
            }
            SchemaEntryPtr       m_SchemaEntry;
            ParseStates          m_State;
            COSEMDataType        m_Choice;
            ssize_t              m_SequenceIndex = -1;
        };
        std::stack<ParseState>   m_GetStates;
        std::stack<ParseState>   m_AppendStates;
        //
        SchemaEntry               m_SingleDataType[2] = { { NULL_DATA }, { END_SCHEMA_T } };
        SchemaEntryPtr            m_pSchema = nullptr;
        SchemaEntryPtr            m_pCurrentSchema = nullptr;
        DLMSVector                m_Data;
    };

    class COSEMBitString : public COSEMType
    {
    public:
        COSEMBitString();
        virtual ~COSEMBitString();
        COSEMBitString(size_t BitsExpected, const DLMSBitSet& Value);
        COSEMBitString(size_t BitsExpected);
        size_t GetBitLength() const;
        //
        // Operators
        //
        operator DLMSValue() const;
        //
        // Helpers
        //
        static bool Peek(SchemaEntryPtr SchemaEntry, const COSEMType& Value, DLMSValue * pVariant, size_t * pBytes = nullptr);
        static bool Get(SchemaEntryPtr SchemaEntry, COSEMType * pValue, DLMSValue * pVariant);

    protected:
        size_t m_BitsExpected;

    };

    // Himanshu
    class COSEMTypeGetVisitor {
        DLMSVector m_Data;
    public:
        COSEMTypeGetVisitor() = delete;
        COSEMTypeGetVisitor(DLMSVector Data)
            : m_Data(Data)
        {
        }
        void Rewind()
        {
            m_Data.SetReadPosition(0);
        }
        size_t GetReadPosition() const
        {
            return m_Data.GetReadPosition();
        }
        bool GetNextValue(DLMSValue * pValue);
        DLMSVector GetNextValueBytes();
    };
}
