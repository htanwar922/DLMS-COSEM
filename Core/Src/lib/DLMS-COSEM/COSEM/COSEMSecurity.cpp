// ===========================================================================
// Copyright (c) 2018, Electric Power Research Institute (EPRI)
// All rights reserved.
//
// DLMS-COSEM ("this software") is licensed under BSD 3-Clause license.
//
// Redistribution and use in source and binary forms, with or without modification,
// are permitted provided that the following conditions are met:
//
// *  Redistributions of source code must retain the above copyright notice, this
//    list of conditions and the following disclaimer.
//
// *  Redistributions in binary form must reproduce the above copyright notice,
//    this list of conditions and the following disclaimer in the documentation
//    and/or other materials provided with the distribution.
//
// *  Neither the name of EPRI nor the names of its contributors may
//    be used to endorse or promote products derived from this software without
//    specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
// IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
// INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
// WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
// OF SUCH DAMAGE.
//
// This EPRI software incorporates work covered by the following copyright and permission
// notices. You may not use these works except in compliance with their respective
// licenses, which are provided below.
//
// These works are provided by the copyright holders and contributors "as is" and any express or
// implied warranties, including, but not limited to, the implied warranties of merchantability
// and fitness for a particular purpose are disclaimed.
//
// This software relies on the following libraries and licenses:
//
// ###########################################################################
// Boost Software License, Version 1.0
// ###########################################################################
//
// * asio v1.10.8 (https://sourceforge.net/projects/asio/files/)
//
// Boost Software License - Version 1.0 - August 17th, 2003
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
//
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.
//

#include "COSEM/COSEMSecurity.h"

namespace EPRI
{
    const ASNObjectIdentifier COSEMSecurityOptions::ContextLNRNoCipher({ 2, 16, 756, 5, 8, 1, 1 });
    const ASNObjectIdentifier COSEMSecurityOptions::ContextSNRNoCipher({ 2, 16, 756, 5, 8, 1, 2 });
    const ASNObjectIdentifier COSEMSecurityOptions::ContextLNRCipher({ 2, 16, 756, 5, 8, 1, 3 });
    const ASNObjectIdentifier COSEMSecurityOptions::ContextSNRCipher({ 2, 16, 756, 5, 8, 1, 4 });

    const ASNObjectIdentifier COSEMSecurityOptions::MechanismNameNoSecurity({ 2, 16, 756, 5, 8, 2, 0 }, ASN::IMPLICIT);
    const ASNObjectIdentifier COSEMSecurityOptions::MechanismNameLowLevelSecurity({ 2, 16, 756, 5, 8, 2, 1 }, ASN::IMPLICIT);
    const ASNObjectIdentifier COSEMSecurityOptions::MechanismNameHighLevelSecurity({ 2, 16, 756, 5, 8, 2, 5 }, ASN::IMPLICIT);
    const ASNObjectIdentifier COSEMSecurityOptions::MechanismNameHighLevelSecurityMD5({ 2, 16, 756, 5, 8, 2, 6 }, ASN::IMPLICIT);
    const ASNObjectIdentifier COSEMSecurityOptions::MechanismNameHighLevelSecuritySHA1({ 2, 16, 756, 5, 8, 2, 7 }, ASN::IMPLICIT);
    const ASNObjectIdentifier COSEMSecurityOptions::MechanismNameHighLevelSecurityGMAC({ 2, 16, 756, 5, 8, 2, 8 }, ASN::IMPLICIT);
    const ASNObjectIdentifier COSEMSecurityOptions::MechanismNameHighLevelSecuritySHA256({ 2, 16, 756, 5, 8, 2, 9 }, ASN::IMPLICIT);
    const ASNObjectIdentifier COSEMSecurityOptions::MechanismNameHighLevelSecurityECDSA({ 2, 16, 756, 5, 8, 2, 10 }, ASN::IMPLICIT);

    COSEMSecurityOptions::COSEMSecurityOptions(SecurityContext::SecuritySuiteOption Suite /*= SecurityContext::NO_SUITE*/
            , uint8_t Policy /*= SecurityContext::no_policy*/)
        : SecurityContext(Suite, Policy)
    {
    }

    COSEMSecurityOptions::~COSEMSecurityOptions()
    {
    }

    COSEMSecurityOptions::SecurityLevel COSEMSecurityOptions::Level() const
    {
        if (MechanismName == MechanismNameLowLevelSecurity)
        {
            return SecurityLevel::SECURITY_LOW_LEVEL;
        }
        else if (MechanismName == MechanismNameHighLevelSecurity
            or MechanismName == MechanismNameHighLevelSecurityMD5
            or MechanismName == MechanismNameHighLevelSecuritySHA1
            or MechanismName == MechanismNameHighLevelSecurityGMAC
            or MechanismName == MechanismNameHighLevelSecuritySHA256
            or MechanismName == MechanismNameHighLevelSecurityECDSA)
        {
            return SecurityLevel::SECURITY_HIGH_LEVEL;
        }
        return SecurityLevel::SECURITY_NONE;
    }

    bool COSEMSecurityOptions::LogicalNameReferencing() const
    {
        return (ApplicationContextName == ContextLNRNoCipher ||
                ApplicationContextName == ContextLNRCipher);
    }

    bool COSEMSecurityOptions::Authentication() const
    {
        return IsInitialized(AuthenticationValue);
    }

    bool COSEMSecurityOptions::Encryption() const
    {
        return (ApplicationContextName == ContextSNRCipher ||
                ApplicationContextName == ContextLNRCipher);
    }

    APDUConstants::AuthenticationValueChoice COSEMSecurityOptions::AuthenticationType() const
    {
        enum AuthenticationValueChoice : int8_t
        {
            charstring = 0,
            bitstring = 1,
            external = 2,
            other = 3
        };
        if (IsSequence(AuthenticationValue))
        {
            return APDUConstants::AuthenticationValueChoice::other;
        }
        switch (VariantType(DLMSValueGetVariant(AuthenticationValue)))
        {
        case VAR_STRING:
            return APDUConstants::AuthenticationValueChoice::charstring;
        case VAR_BITSET:
            return APDUConstants::AuthenticationValueChoice::bitstring;
        case VAR_VECTOR:
            return APDUConstants::AuthenticationValueChoice::external;
        default:
            return APDUConstants::AuthenticationValueChoice::other;
        }
    }

    SecurityContext::SecurityContext(SecuritySuiteOption Suite, uint8_t Policy)
        : m_SuiteOption(Suite)
        , m_Policy(Policy)
        , m_pSecuritySuite(nullptr)
    {
    }

    SecurityContext::~SecurityContext()
    {
    }

    const std::shared_ptr<ISecuritySuite> SecurityContext::GetSecuritySuite() const
    {
        return m_pSecuritySuite;
    }

    void SecurityContext::SetSecuritySuite(const ISecuritySuite& riSuite)
    {
        if (m_pSecuritySuite)
        {
            m_pSecuritySuite.~shared_ptr();
        }
        if (nullptr != dynamic_cast<const SecuritySuite_None*>(&riSuite))
        {
            m_SuiteOption = NO_SUITE;
            //m_pSecuritySuite = new SecuritySuite_None();
            m_pSecuritySuite = std::make_shared<SecuritySuite_None>();
        }
        else if (nullptr != dynamic_cast<const SecuritySuite_0 *>(&riSuite))
        {
            m_SuiteOption = SUITE_0;
            const SecuritySuite_0 & rSuite = dynamic_cast<const SecuritySuite_0 &>(riSuite);
            //m_pSecuritySuite = new SecuritySuite_0(rSuite.GetKey().GetData(), rSuite.GetAAD().GetData());
            m_pSecuritySuite = std::make_shared<SecuritySuite_0>(rSuite.GetKey().GetData(), rSuite.GetAAD().GetData());
        }
        else if (nullptr != dynamic_cast<const SecuritySuite_1*>(&riSuite))
        {
            m_SuiteOption = SUITE_1;
            throw std::runtime_error("SecuritySuite_1 not implemented");
        }
        else if (nullptr != dynamic_cast<const SecuritySuite_2*>(&riSuite))
        {
            m_SuiteOption = SUITE_2;
            throw std::runtime_error("SecuritySuite_2 not implemented");
        }
        else
        {
            throw std::runtime_error("Unknown Security Suite");
        }
    }

    uint8_t SecurityContext::GetPolicy() const
    {
        return m_Policy;
    }

    void SecurityContext::ClearPolicy()
    {
        m_Policy = 0;
    }

    void SecurityContext::SetPolicyBit(SecurityPolicyBitmask policy)
    {
        m_Policy |= policy;
    }

    const COSEMObjectInstanceID& SecurityContext::GetSecuritySetupObjectID() const
    {
        if (m_pSecuritySuite == nullptr)
        {
            throw std::runtime_error("Security Suite not set");
        }
        return m_pSecuritySuite->GetSecuritySetupObjectID();
    }

    void SecurityContext::SetSecuritySetupObjectID(const COSEMObjectInstanceID& ID)
    {
        if (m_pSecuritySuite == nullptr)
        {
            throw std::runtime_error("Security Suite not set");
        }
        m_pSecuritySuite->SetSecuritySetupObjectID(ID);
    }
}