// ===========================================================================
// Copyright (c) 2018, Electric Power Research Institute (EPRI)
// All rights reserved.
//
// DLMS-COSEM ("this software") is licensed under BSD 3-Clause license.
//
// Redistribution and use in source and binary forms, with or without modification,
// are permitted provided that the following conditions are met:
//
// *  Redistributions of source code must retain the above copyright notice, this
//    list of conditions and the following disclaimer.
//
// *  Redistributions in binary form must reproduce the above copyright notice,
//    this list of conditions and the following disclaimer in the documentation
//    and/or other materials provided with the distribution.
//
// *  Neither the name of EPRI nor the names of its contributors may
//    be used to endorse or promote products derived from this software without
//    specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
// IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
// INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
// WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
// OF SUCH DAMAGE.
//
// This EPRI software incorporates work covered by the following copyright and permission
// notices. You may not use these works except in compliance with their respective
// licenses, which are provided below.
//
// These works are provided by the copyright holders and contributors "as is" and any express or
// implied warranties, including, but not limited to, the implied warranties of merchantability
// and fitness for a particular purpose are disclaimed.
//
// This software relies on the following libraries and licenses:
//
// ###########################################################################
// Boost Software License, Version 1.0
// ###########################################################################
//
// * asio v1.10.8 (https://sourceforge.net/projects/asio/files/)
//
// Boost Software License - Version 1.0 - August 17th, 2003
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
//
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.
//

#include <algorithm>
#include <set>
#include <stdexcept>

#include "APDU/ASNType.h"
#include "interfaces/COSEMData.h"

namespace EPRI
{
    COSEM_BEGIN_SCHEMA(OctetStringSchema)
        COSEM_OCTET_STRING_TYPE
    COSEM_END_SCHEMA
    COSEM_BEGIN_SCHEMA(LongSchema)
        COSEM_LONG_TYPE
    COSEM_END_SCHEMA
    COSEM_BEGIN_SCHEMA(UnsignedSchema)
        COSEM_UNSIGNED_TYPE
    COSEM_END_SCHEMA
    COSEM_BEGIN_SCHEMA(IntegerSchema)
        COSEM_INTEGER_TYPE
    COSEM_END_SCHEMA
    COSEM_BEGIN_SCHEMA(BooleanSchema)
        COSEM_BOOLEAN_TYPE
    COSEM_END_SCHEMA
    COSEM_BEGIN_SCHEMA(DoubleLongUnsignedSchema)    // Himanshu
        COSEM_DOUBLE_LONG_UNSIGNED_TYPE
    COSEM_END_SCHEMA
    COSEM_BEGIN_SCHEMA(Float32Schema)    // Himanshu
        COSEM_FLOAT32_TYPE
    COSEM_END_SCHEMA

    //
    // COSEMType
    //
    COSEMType::COSEMType()
    {
    }

    COSEMType::COSEMType(SchemaEntryPtr Schema)
        : m_pSchema(Schema)
        , m_pCurrentSchema(Schema)
    {
    }

    COSEMType::COSEMType(SchemaBaseType DT)
        : m_pSchema(m_SingleDataType)
        , m_pCurrentSchema(m_SingleDataType)
    {
        m_SingleDataType[0].m_SchemaType = DT;
    }

    COSEMType::COSEMType(SchemaBaseType DT, const DLMSValue& Value)
        : m_pSchema(m_SingleDataType)
        , m_pCurrentSchema(m_SingleDataType)
    {
        m_SingleDataType[0].m_SchemaType = DT;
        InternalAppend(Value);
        Rewind();
    }

    COSEMType::~COSEMType()
    {
    }

    void COSEMType::GetBytes(DLMSVector * pDestination) const
    {
        pDestination->Append(m_Data.GetBytes());
    }

    std::vector<uint8_t> COSEMType::GetBytes() const
    {
        return m_Data.GetBytes();
    }

    bool COSEMType::IsEmpty() const
    {
        return m_Data.Size() == 0;
    }

    void COSEMType::Clear()
    {
        m_Data.Clear();
        Rewind();
    }

    void COSEMType::Rewind()
    {
        m_pCurrentSchema = m_pSchema;
        m_Data.SetReadPosition(0);
        while (m_GetStates.size())
        {
            m_GetStates.pop();
        }
        while (m_AppendStates.size())
        {
            m_AppendStates.pop();
        }
    }

    bool COSEMType::Parse(DLMSVector * pData)
    {
        return m_Data.Append(pData) >= 0;
    }

    bool COSEMType::Parse(const DLMSVector& Data)
    {
        return m_Data.Append(Data) >= 0;
    }

#define CURRENT_APPEND_STATE m_AppendStates.top()
    bool COSEMType::SelectChoice(COSEMDataType Choice)
    {
        //
        // PRECONDITIONS
        //
        if (m_AppendStates.empty())
        {
            m_AppendStates.emplace(nullptr, ST_SIMPLE, Choice);
            return true;
        }
        //
        // The only time we can select a choice is if we are sitting within
        // a CHOICE section.
        //
        if (nullptr != CURRENT_APPEND_STATE.m_SchemaEntry)
        {
            CURRENT_APPEND_STATE.m_Choice = Choice;
            return true;
        }
        return false;
    }

#define CURRENT_GET_STATE m_GetStates.top()
    bool COSEMType::GetChoice(COSEMDataType * pChoice)
    {
        if (m_GetStates.size() && INVALID_CHOICE != CURRENT_GET_STATE.m_Choice)
        {
            *pChoice = CURRENT_GET_STATE.m_Choice;
            return true;
        }
        return false;

    }

    COSEMType::GetNextResult COSEMType::InternalSimpleGet(SchemaEntryPtr SchemaEntry, DLMSValue * pValue)
    {
        GetNextResult RetVal = INVALID_CONDITION;
        COSEMDataType DT = COSEMDataType(m_Data.Get<uint8_t>());
        if (DT != COSEM_SCHEMA_DATA_TYPE(SchemaEntry))
        {
            return INVALID_STREAM;
        }
        switch (DT)
        {
        case NULL_DATA:
            pValue->set<blank>();
            return VALUE_RETRIEVED;
        case BOOLEAN:
            RetVal = m_Data.Get<bool>(pValue) ? VALUE_RETRIEVED : INVALID_CONDITION;
            break;
        case BIT_STRING:
            RetVal = COSEMBitString::Get(SchemaEntry, this, pValue) ? VALUE_RETRIEVED : INVALID_CONDITION;
            break;
        case DOUBLE_LONG:
            RetVal = m_Data.Get<int32_t>(pValue) ? VALUE_RETRIEVED : INVALID_CONDITION;
            break;
        case DOUBLE_LONG_UNSIGNED:
            RetVal = m_Data.Get<uint32_t>(pValue) ? VALUE_RETRIEVED : INVALID_CONDITION;
            break;
        case OCTET_STRING:
            {
                size_t     Length = 0;
                DLMSVector Vector;
                if (ASNType::GetLength(&m_Data, &Length) &&
                    m_Data.GetVector(&Vector, Length))
                {
                    *pValue = Vector;
                    RetVal = VALUE_RETRIEVED;
                }
                else
                {
                    RetVal = INVALID_CONDITION;
                }
            }
            break;
        case VISIBLE_STRING:
            {
                size_t      Length = 0;
                std::string String;
                if (ASNType::GetLength(&m_Data, &Length) &&
                    m_Data.Get(&String, Length))
                {
                    *pValue = String;
                    RetVal = VALUE_RETRIEVED;
                }
                else
                {
                    RetVal = INVALID_CONDITION;
                }
            }
            break;
        case UTF8_STRING:
            LOG_ERROR("InternalSimpleGet: Type %x not implemented : UTF-8 string.\r\n", DT);
            break;
        case INTEGER:
            RetVal = m_Data.Get<int8_t>(pValue) ? VALUE_RETRIEVED : INVALID_CONDITION;
            break;
        case ENUM:
        case UNSIGNED:
            RetVal = m_Data.Get<uint8_t>(pValue) ? VALUE_RETRIEVED : INVALID_CONDITION;
            break;
        case LONG:
            RetVal = m_Data.Get<int16_t>(pValue) ? VALUE_RETRIEVED : INVALID_CONDITION;
            break;
        case LONG_UNSIGNED:
            RetVal = m_Data.Get<uint16_t>(pValue) ? VALUE_RETRIEVED : INVALID_CONDITION;
            break;
        case LONG64:
            RetVal = m_Data.Get<int64_t>(pValue) ? VALUE_RETRIEVED : INVALID_CONDITION;
            break;
        case LONG64_UNSIGNED:
            RetVal = m_Data.Get<uint64_t>(pValue) ? VALUE_RETRIEVED : INVALID_CONDITION;
            break;
        case FLOATING_POINT:
        case FLOAT32:
            RetVal = m_Data.Get<float>(pValue) ? VALUE_RETRIEVED : INVALID_CONDITION;
            break;
        case FLOAT64:
            RetVal = m_Data.Get<double>(pValue) ? VALUE_RETRIEVED : INVALID_CONDITION;
            break;
        case BCD:
        case DATE_TIME:
        case DATE:
        case TIME:
        case DONT_CARE:
        default:
            LOG_ERROR("InternalSimpleGet: Type %x not implemented.\r\n", DT);
            // throw std::out_of_range("InternalSimpleGet: Type not implemented.");
        }
        return RetVal;
    }

    COSEMType::GetNextResult COSEMType::GetNextValue(DLMSValue * pValue)
    {
        GetNextResult       GetNextRetVal = INVALID_CONDITION;
        DLMSStructure       Structure;
        DLMSArray           Array;
        //
        // PRECONDITIONS
        //
        if (m_Data.Size() == 0)
        {
            return VALUE_EMPTY;
        }
        if (m_Data.IsAtEnd())
        {
            return END_OF_SCHEMA;
        }
        if (m_GetStates.empty())
        {
            m_GetStates.emplace(nullptr, ST_SIMPLE, INVALID_CHOICE);
        }
        while (VALUE_RETRIEVED == (GetNextRetVal = GetNextSchemaEntry(&CURRENT_GET_STATE.m_SchemaEntry)))
        {
            switch (CURRENT_GET_STATE.m_State)
            {
            case ST_SIMPLE:
                if (BEGIN_CHOICE_T ==
                    COSEM_SCHEMA_INTERNAL_DATA_TYPE(CURRENT_GET_STATE.m_SchemaEntry))
                {
                    m_GetStates.emplace(nullptr, ST_CHOICE, INVALID_CHOICE);
                    break;
                }
                else if (COSEM_IS_STRUCTURE_BEGIN(CURRENT_GET_STATE.m_SchemaEntry))
                {
                    m_GetStates.emplace(nullptr, ST_STRUCTURE, INVALID_CHOICE);
                    break;
                }
                else if (COSEM_IS_ARRAY_BEGIN(CURRENT_GET_STATE.m_SchemaEntry))
                {
                    m_GetStates.emplace(nullptr, ST_ARRAY, INVALID_CHOICE);
                    break;
                }
                else
                {
                    DLMSValue Value;
                    GetNextRetVal = InternalSimpleGet(CURRENT_GET_STATE.m_SchemaEntry, &Value);
                    if (VALUE_RETRIEVED == GetNextRetVal)
                    {
                        *pValue = Value;
                    }
                    return GetNextRetVal;
                }
                return SCHEMA_MISMATCH;
            case ST_CHOICE:
                if (END_CHOICE_T == COSEM_SCHEMA_INTERNAL_DATA_TYPE(CURRENT_GET_STATE.m_SchemaEntry))
                {
                    m_GetStates.pop();
                }
                else if (COSEMDataType(m_Data.PeekByte()) == COSEM_SCHEMA_DATA_TYPE(CURRENT_GET_STATE.m_SchemaEntry))
                {
                    CURRENT_GET_STATE.m_Choice = COSEM_SCHEMA_DATA_TYPE(CURRENT_GET_STATE.m_SchemaEntry);
                    if (COSEM_IS_STRUCTURE_BEGIN(CURRENT_GET_STATE.m_SchemaEntry))
                    {
                        m_GetStates.emplace(nullptr, ST_STRUCTURE, CURRENT_GET_STATE.m_Choice);
                        break;
                    }
                    else if (COSEM_IS_ARRAY_BEGIN(CURRENT_GET_STATE.m_SchemaEntry))
                    {
                        m_GetStates.emplace(nullptr, ST_ARRAY, CURRENT_GET_STATE.m_Choice);
                        break;
                    }
                    else
                    {
                        DLMSValue Value;
                        GetNextRetVal = InternalSimpleGet(CURRENT_GET_STATE.m_SchemaEntry, &Value);
                        if (VALUE_RETRIEVED == GetNextRetVal)
                        {
                            *pValue = Value;
                        }
                        return GetNextRetVal;
                    }
                }
                break;
            case ST_STRUCTURE:
            {
                if (COSEM_IS_STRUCTURE_END(CURRENT_GET_STATE.m_SchemaEntry))
                {
                    m_GetStates.pop();
                    *pValue = Structure;
                    if (Structure.size())
                    {
                        return VALUE_RETRIEVED;
                    }
                    return NO_VALUE_FOUND;
                }
                else if (BEGIN_CHOICE_T == COSEM_SCHEMA_INTERNAL_DATA_TYPE(CURRENT_GET_STATE.m_SchemaEntry))
                {
                    m_GetStates.emplace(nullptr, ST_CHOICE, INVALID_CHOICE);
                    break;
                }
                else
                {
                    //
                    // PRECONDITIONS
                    //
                    if (-1 == CURRENT_GET_STATE.m_SequenceIndex)
                    {
                        size_t ExpectedLength = 0;
                        if (m_Data.Get<uint8_t>() == COSEMDataType::STRUCTURE &&
                            ASNType::GetLength(&m_Data, &ExpectedLength) &&
                            (uint8_t)ExpectedLength == StructureElementCount(CURRENT_GET_STATE.m_SchemaEntry))
                        {
                            CURRENT_GET_STATE.m_SequenceIndex = ExpectedLength;
                        }
                        else
                        {
                            return SCHEMA_MISMATCH;
                        }
                    }

                    while(CURRENT_GET_STATE.m_SequenceIndex--) {
                        COSEMDataType DT = COSEMDataType(m_Data.PeekByte());
                        if (DT != COSEM_SCHEMA_DATA_TYPE(CURRENT_GET_STATE.m_SchemaEntry)) {
                            return SCHEMA_MISMATCH;
                        }
                        if (BEGIN_SPECIAL_T == COSEM_SCHEMA_INTERNAL_DATA_TYPE(CURRENT_GET_STATE.m_SchemaEntry))
                        {
                            DLMSValue Value;
                            SchemaEntryPtr _SchemaEntry = CURRENT_GET_STATE.m_SchemaEntry;

                            if (DT == STRUCTURE)
                                m_GetStates.emplace(nullptr, ST_STRUCTURE, INVALID_CHOICE);
                            else if (DT == ARRAY)
                                m_GetStates.emplace(nullptr, ST_ARRAY, INVALID_CHOICE);

                            CURRENT_GET_STATE.m_SchemaEntry = _SchemaEntry;
                            CURRENT_GET_STATE.m_SequenceIndex = -1;

                            GetNextRetVal = GetNextValue(&Value);
                            if (VALUE_RETRIEVED == GetNextRetVal)
                            {
                                Structure.push_back(Value);
                            }
                            else {
                                // printf("\t\t\tHere 1\r\n");
                                break;
                            }
                        }
                        else
                        {
                            DLMSValue Value;
                            GetNextRetVal = InternalSimpleGet(CURRENT_GET_STATE.m_SchemaEntry, &Value);
                            // printf("\t\tSIMPLE TYPE %d : ", Value.which()); Print(&Value); printf("\r\n");

                            if (VALUE_RETRIEVED == GetNextRetVal)
                            {
                                Structure.push_back(Value);
                            }
                            else {
                                // printf("\t\t\tHere 2\r\n");
                                break;
                            }
                        }
                        if(CURRENT_GET_STATE.m_SequenceIndex > 0 and VALUE_RETRIEVED != GetNextSchemaEntry(&CURRENT_GET_STATE.m_SchemaEntry)) {
                            break;
                        }
                    }
                    if (CURRENT_GET_STATE.m_SequenceIndex == -1) {
                        GetNextRetVal = VALUE_RETRIEVED;
                        break;
                    }
                }
                return SCHEMA_MISMATCH;
            }
            case ST_ARRAY:
            {
                if (COSEM_IS_ARRAY_END(CURRENT_GET_STATE.m_SchemaEntry))
                {
                    m_GetStates.pop();
                    if (GetNextRetVal == VALUE_RETRIEVED)
                    {
                        *pValue = Array;
                        return VALUE_RETRIEVED;
                    }
                    return NO_VALUE_FOUND;
                }
                else if (BEGIN_CHOICE_T == COSEM_SCHEMA_INTERNAL_DATA_TYPE(CURRENT_GET_STATE.m_SchemaEntry))
                {
                    m_GetStates.emplace(nullptr, ST_CHOICE, INVALID_CHOICE);
                    break;
                }
                else
                {
                    //
                    // PRECONDITIONS
                    //
                    if (-1 == CURRENT_GET_STATE.m_SequenceIndex)
                    {
                        size_t ExpectedLength = 0;
                        if (m_Data.Get<uint8_t>() == COSEMDataType::ARRAY &&
                            ASNType::GetLength(&m_Data, &ExpectedLength))
                        {
                            CURRENT_GET_STATE.m_SequenceIndex = ExpectedLength;
                            // printf("LENGTH OF ARRAY : %ld\r\n", ExpectedLength);
                        }
                        else
                        {
                            return SCHEMA_MISMATCH;
                        }
                    }

                    SchemaEntryPtr _SchemaEntry = CURRENT_GET_STATE.m_SchemaEntry;
                    SchemaEntryPtr _pCurrentSchema = m_pCurrentSchema;
                    while(CURRENT_GET_STATE.m_SequenceIndex--) {
                        m_pCurrentSchema = _pCurrentSchema;
                        CURRENT_GET_STATE.m_SchemaEntry = _SchemaEntry;
                        COSEMDataType DT = COSEMDataType(m_Data.PeekByte());
                        if (DT != COSEM_SCHEMA_DATA_TYPE(CURRENT_GET_STATE.m_SchemaEntry)) {
                            return SCHEMA_MISMATCH;
                        }

                        DLMSValue Value;
                        if (COSEM_IS_BEGINNING(CURRENT_GET_STATE.m_SchemaEntry)) {
                            if (DT == STRUCTURE)
                                m_GetStates.emplace(nullptr, ST_STRUCTURE, INVALID_CHOICE);
                            else if (DT == ARRAY)
                                m_GetStates.emplace(nullptr, ST_ARRAY, INVALID_CHOICE);
                            else
                                m_GetStates.emplace(nullptr, ST_CHOICE, INVALID_CHOICE);
                            CURRENT_GET_STATE.m_SchemaEntry = _SchemaEntry;
                            CURRENT_GET_STATE.m_SequenceIndex = -1;
                            GetNextRetVal = GetNextValue(&Value);
                        }
                        else {
                            DLMSValue Variant;
                            GetNextRetVal = InternalSimpleGet(CURRENT_GET_STATE.m_SchemaEntry, &Variant);
                            Value = Variant;
                        }

                        if (VALUE_RETRIEVED == GetNextRetVal)
                        {
                            Array.push_back(Value);
                        }
                        else {
                            break;
                        }
                        if(CURRENT_GET_STATE.m_SequenceIndex > 0 and VALUE_RETRIEVED != GetNextSchemaEntry(&CURRENT_GET_STATE.m_SchemaEntry)) {
                            break;
                        }
                    }
                    if (CURRENT_GET_STATE.m_SequenceIndex == -1) {
                        GetNextRetVal = VALUE_RETRIEVED;
                        break;
                    }
                }
                return SCHEMA_MISMATCH;
            }
            default:
                throw std::out_of_range("GetNextValue Not implemented.");
            }
        }
        return GetNextRetVal;
    }

    bool COSEMType::Append(const DLMSValue& Value)
    {
        return InternalAppend(Value);
    }

    bool COSEMType::Append()
    {
        //
        // NULL-DATA Case
        //
        return InternalAppend(DLMSBlank);
    }
    //
    // Operators
    //
    bool COSEMType::operator==(const std::vector<uint8_t>& rhs) const
    {
        return rhs == m_Data.GetBytes();
    }

    bool COSEMType::operator==(const COSEMType& rhs) const
    {
        return rhs.m_Data == m_Data;
    }

    COSEMType& COSEMType::operator=(const DLMSVector& rhs)
    {
        m_Data = rhs;
        return *this;
    }

    COSEMType::operator const DLMSVector&()
    {
        return m_Data;
    }

    //
    // Protected Methods
    //
    void COSEMType::SetSchemaType(SchemaBaseType DT)
    {
        m_pSchema = m_SingleDataType;
        m_SingleDataType[0].m_SchemaType = DT;
        Clear();
    }

    COSEMType::GetNextResult COSEMType::GetNextSchemaEntry(SchemaEntryPtr * ppSchemaEntry)
    {
        *ppSchemaEntry = m_pCurrentSchema;
        if (nullptr == m_pCurrentSchema)
        {
            return INVALID_CONDITION;
        }

        if (!COSEM_IS_SCHEMA_END(m_pCurrentSchema))
        {
            ++m_pCurrentSchema;
            return VALUE_RETRIEVED;
        }
        return END_OF_SCHEMA;
    }

    class COSEMTypeAppendVisitor
    {
    public:
        COSEMTypeAppendVisitor() = delete;
        COSEMTypeAppendVisitor(SchemaEntryPtr SchemaEntry, DLMSVector * pVector)
            : m_SchemaEntry(SchemaEntry), m_pVector(pVector)
        {
        }

        void operator()(const blank& Value)
        {
            m_SchemaEntry++;
        }
        void operator()(const bool& Value)
        {
            IntegralAppend(Value ? 1 : 0);
        }
        void operator()(const int8_t& Value)
        {
            IntegralAppend(Value);
        }
        void operator()(const uint8_t& Value)
        {
            IntegralAppend(Value);
        }
        void operator()(const int16_t& Value)
        {
            IntegralAppend(Value);
        }
        void operator()(const uint16_t& Value)
        {
            IntegralAppend(Value);
        }
        void operator()(const int32_t& Value)
        {
            IntegralAppend(Value);
        }
        void operator()(const uint32_t& Value)
        {
            IntegralAppend(Value);
        }
        void operator()(const int64_t& Value)
        {
            IntegralAppend(Value);
        }
        void operator()(const uint64_t& Value)
        {
            IntegralAppend(Value);
        }
        void operator()(const std::string& Value)
        {
            switch (COSEM_SCHEMA_DATA_TYPE(m_SchemaEntry))
            {
            case NULL_DATA:
                break;
            case VISIBLE_STRING:
                ASNType::AppendLength(Value.length(), m_pVector);
                m_pVector->Append(Value);
                break;
            default:
                throw std::logic_error("Not implemented");
            }
            m_SchemaEntry++;
        }
        void operator()(const double& Value)
        {
            FloatingPointAppend(Value);
        }
        void operator()(const DLMSVector& Value)
        {
            switch (COSEM_SCHEMA_DATA_TYPE(m_SchemaEntry))
            {
            case NULL_DATA:
                break;
            case BIT_STRING:
                m_pVector->Append(Value);
                break;
            case OCTET_STRING:
                {
                    size_t Length = Value.Size();
                    ASNType::AppendLength(Length, m_pVector);
                    m_pVector->Append(Value, 0, Length);
                }
                break;
            default:
                throw std::logic_error("Not implemented");
            }
            m_SchemaEntry++;
        }
        void operator()(const DLMSInitList& Value)
        {
            throw std::logic_error("Not implemented");
        }
        void operator()(const DLMSBitSet& Value)
        {
            switch (COSEM_SCHEMA_DATA_TYPE(m_SchemaEntry))
            {
            case NULL_DATA:
                break;
            case BIT_STRING:
                {
                    COSEMBitString Conversion(COSEM_SCHEMA_DATA_TYPE_SIZE(m_SchemaEntry),
                                             Value);
                    Conversion.GetBytes(m_pVector);
                }
                break;
            default:
                throw std::logic_error("Not implemented");
            }
            m_SchemaEntry++;
        }
        void operator()(const DLMSStructure& Value)
        {
            throw std::logic_error("Not implemented");
            // ASNType::AppendLength(Value.size(), m_pVector);
            // for (auto& Element : Value)
            // {
            //     DLMSVector Data;
            //     COSEMTypeAppendVisitor Visitor(m_SchemaEntry, &Data);
            //     Element.apply_visitor(Visitor);
            //     m_pVector->Append(Data);
            //     m_SchemaEntry = Visitor.m_SchemaEntry;
            // }
            // m_SchemaEntry++;
        }
        void operator()(const DLMSArray& Value)
        {
            throw std::logic_error("Not implemented");
            // switch (COSEM_SCHEMA_DATA_TYPE(m_SchemaEntry))
            // {
            // case NULL_DATA:
            //     break;
            // case ARRAY:
            //     {
            //         ASNType::AppendLength(Value.size(), m_pVector);
            //         for (auto& Element : Value)
            //         {
            //             // COSEMTypeAppendVisitor Visitor(Element.m_SchemaEntry, m_pVector);
            //             // apply_visitor(Visitor, Element.m_Value);
            //         }
            //     }
            //     break;
            // default:
            //     throw std::logic_error("Not implemented");
            // }
        }

    protected:
        void IntegralAppend(uint64_t VectorValue)
        {
            switch (COSEM_SCHEMA_DATA_TYPE(m_SchemaEntry))
            {
            case NULL_DATA:
                break;
            case UNSIGNED:
            case BOOLEAN:
            case ENUM:
                m_pVector->Append<uint8_t>(VectorValue);
                break;
            case DOUBLE_LONG:
                m_pVector->Append<int32_t>(VectorValue);
                break;
            case DOUBLE_LONG_UNSIGNED:
                m_pVector->Append<uint32_t>(VectorValue);
                break;
            case INTEGER:
                m_pVector->Append<int8_t>(VectorValue);
                break;
            case LONG:
                m_pVector->Append<int16_t>(VectorValue);
                break;
            case LONG_UNSIGNED:
                m_pVector->Append<uint16_t>(VectorValue);
                break;
            case LONG64:
                m_pVector->Append<int64_t>(VectorValue);
                break;
            case LONG64_UNSIGNED:
                m_pVector->Append<uint64_t>(VectorValue);
                break;
            default:
                throw std::logic_error("Not implemented");
            }
            m_SchemaEntry++;
        }

        void FloatingPointAppend(double VectorValue)
        {
            switch (COSEM_SCHEMA_DATA_TYPE(m_SchemaEntry))
            {
            case NULL_DATA:
                break;
			// Himanshu - implemented FLOAT32 and FLOAT64 cases
			case FLOAT32:
				m_pVector->AppendFloat((float)VectorValue);
				break;
			case FLOAT64:
				m_pVector->AppendDouble(VectorValue);
				break;
            default:
                throw std::logic_error("Not implemented");
            }
            m_SchemaEntry++;
        }

        SchemaEntryPtr m_SchemaEntry;
        DLMSVector *   m_pVector;
    };

    bool COSEMType::InternalSimpleAppend(SchemaEntryPtr SchemaEntry, const DLMSValue& Value)
    {
        if (COSEMDataType::ANY_TYPE == COSEM_SCHEMA_DATA_TYPE(SchemaEntry))
        {
            return InternalAnyAppend(Value);
        }
        m_Data.Append(uint8_t(COSEM_SCHEMA_DATA_TYPE(SchemaEntry)));
        try
        {
            COSEMTypeAppendVisitor Visitor(SchemaEntry, &m_Data);
            Value.apply_visitor(Visitor);
        }
        catch (const std::exception&)
        {
            return false;
        }
        return true;
    }

    bool COSEMType::InternalAnyAppend(const DLMSValue& Value)
    {
        switch (Value.which())
        {
        case DLMSValueIndex::VAR_BLANK:
            m_Data.Append<uint8_t>(COSEMDataType::NULL_DATA);
            break;
        case DLMSValueIndex::VAR_BOOL:
            m_Data.Append<uint8_t>(COSEMDataType::BOOLEAN);
            m_Data.Append<bool>(DLMSValueGet<bool>(Value));
            break;
        case DLMSValueIndex::VAR_INT8:
            m_Data.Append<uint8_t>(COSEMDataType::INTEGER);
            m_Data.Append<int8_t>(DLMSValueGet<int8_t>(Value));
            break;
        case DLMSValueIndex::VAR_UINT8:
            m_Data.Append<uint8_t>(COSEMDataType::UNSIGNED);
            m_Data.Append<uint8_t>(DLMSValueGet<uint8_t>(Value));
            break;
        case DLMSValueIndex::VAR_INT16:
            m_Data.Append<uint8_t>(COSEMDataType::LONG);
            m_Data.Append<int16_t>(DLMSValueGet<int16_t>(Value));
            break;
        case DLMSValueIndex::VAR_UINT16:
            m_Data.Append<uint8_t>(COSEMDataType::LONG_UNSIGNED);
            m_Data.Append<uint16_t>(DLMSValueGet<uint16_t>(Value));
            break;
        case DLMSValueIndex::VAR_INT32:
            m_Data.Append<uint8_t>(COSEMDataType::DOUBLE_LONG);
            m_Data.Append<int32_t>(DLMSValueGet<int32_t>(Value));
            break;
        case DLMSValueIndex::VAR_UINT32:
            m_Data.Append<uint8_t>(COSEMDataType::DOUBLE_LONG_UNSIGNED);
            m_Data.Append<uint32_t>(DLMSValueGet<uint32_t>(Value));
            break;
        case DLMSValueIndex::VAR_INT64:
            m_Data.Append<uint8_t>(COSEMDataType::LONG64);
            m_Data.Append<int64_t>(DLMSValueGet<int64_t>(Value));
            break;
        case DLMSValueIndex::VAR_UINT64:
            m_Data.Append<uint8_t>(COSEMDataType::LONG64_UNSIGNED);
            m_Data.Append<uint64_t>(DLMSValueGet<uint64_t>(Value));
            break;
        case DLMSValueIndex::VAR_FLOAT:
            m_Data.Append<uint8_t>(COSEMDataType::FLOAT32);
            m_Data.AppendFloat(DLMSValueGet<float>(Value));
            break;
        case DLMSValueIndex::VAR_DOUBLE:
            m_Data.Append<uint8_t>(COSEMDataType::FLOAT64);
            m_Data.AppendDouble(DLMSValueGet<double>(Value));
            break;
        case DLMSValueIndex::VAR_BITSET:
            {
                throw std::logic_error("Not implemented");
                //DLMSBitSet BitString = DLMSValueGet<DLMSBitSet>(Value);
                //m_Data.Append<uint8_t>(COSEMDataType::BIT_STRING);
                //ASNType::AppendLength(BitString.size(), &m_Data);
                ////m_Data.Append(BitString);
                //m_Data.Append(BitString.GetBytes());
            }
            break;
        case DLMSValueIndex::VAR_STRING:
            {
                std::string String = DLMSValueGet<std::string>(Value);
                m_Data.Append<uint8_t>(COSEMDataType::VISIBLE_STRING);
                ASNType::AppendLength(String.length(), &m_Data);
                m_Data.Append(String);
            }
            break;
        case DLMSValueIndex::VAR_VECTOR:
            {
                DLMSVector Vector = DLMSValueGet<DLMSVector>(Value);
                m_Data.Append<uint8_t>(COSEMDataType::OCTET_STRING);
                ASNType::AppendLength(Vector.Size(), &m_Data);
                m_Data.Append(Vector);
            }
            break;
        case DLMSValueIndex::VAR_STRUCTURE:
            {
                DLMSStructure Structure = DLMSValueGet<DLMSStructure>(Value);
                m_Data.Append<uint8_t>(COSEMDataType::STRUCTURE);
                ASNType::AppendLength(Structure.size(), &m_Data);
                for (auto& Element : Structure)
                {
                    InternalAnyAppend(Element);
                }
            }
            break;
        case DLMSValueIndex::VAR_ARRAY:
            {
                DLMSArray Array = DLMSValueGet<DLMSArray>(Value);
                m_Data.Append<uint8_t>(COSEMDataType::ARRAY);
                ASNType::AppendLength(Array.size(), &m_Data);
                for (auto& Element : Array)
                {
                    InternalAnyAppend(Element);
                }
            }
            break;
        default:
            return false;
        }
        return true;
    }

    // Himanshu
    ssize_t COSEMType::StructureElementCount(SchemaEntryPtr pSchemaEntry) const
    {
        ssize_t        ElementCount = 0;
        size_t         Level = 0;
        SchemaEntryPtr pEntry = /*++*/pSchemaEntry;

        while (!COSEM_IS_SCHEMA_END(pEntry))
        {
            if (COSEM_IS_BEGINNING(pEntry))
            {
                ++Level;
            }
            else if (COSEM_IS_ENDING(pEntry))
            {
                if (0 == Level and COSEM_IS_STRUCTURE_END(pEntry))
                {
                    return /*++*/ElementCount;
                }
                --Level;
            }
            if (0 == Level)
            {
                ++ElementCount;
            }
            ++pEntry;
        }
        return -1;
    }

    bool COSEMType::InternalAppend(const DLMSValue& Value)
    {
        bool RetVal = true;
        if (m_AppendStates.empty())
        {
            m_AppendStates.emplace(nullptr, ST_SIMPLE, INVALID_CHOICE);
        }
        while (VALUE_RETRIEVED == GetNextSchemaEntry(&CURRENT_APPEND_STATE.m_SchemaEntry))
        {
            switch (CURRENT_APPEND_STATE.m_State)
            {
            case ST_SIMPLE:
                if (BEGIN_CHOICE_T == COSEM_SCHEMA_INTERNAL_DATA_TYPE(CURRENT_APPEND_STATE.m_SchemaEntry))
                {
                    m_AppendStates.emplace(nullptr, ST_CHOICE, CURRENT_APPEND_STATE.m_Choice);
                    break;
                }
                else if (COSEM_IS_STRUCTURE_BEGIN(CURRENT_APPEND_STATE.m_SchemaEntry))
                {
                    m_AppendStates.emplace(nullptr, ST_STRUCTURE, CURRENT_APPEND_STATE.m_Choice);
                    break;
                }
                else if (COSEM_IS_ARRAY_BEGIN(CURRENT_APPEND_STATE.m_SchemaEntry))      // Himanshu - added this block
                {
                    m_AppendStates.emplace(nullptr, ST_ARRAY, CURRENT_APPEND_STATE.m_Choice);
                    break;
                }
                else
                {
                    return InternalSimpleAppend(CURRENT_APPEND_STATE.m_SchemaEntry, Value);
                }
            case ST_CHOICE:
                if (END_CHOICE_T == COSEM_SCHEMA_INTERNAL_DATA_TYPE(CURRENT_APPEND_STATE.m_SchemaEntry))
                {
                    m_AppendStates.pop();
                    return true;
                }
                else if (CURRENT_APPEND_STATE.m_Choice == COSEM_SCHEMA_DATA_TYPE(CURRENT_APPEND_STATE.m_SchemaEntry))
                {
                    if ((COSEMDataType::STRUCTURE == CURRENT_APPEND_STATE.m_Choice) &&
                        COSEM_IS_STRUCTURE_BEGIN(CURRENT_APPEND_STATE.m_SchemaEntry))
                    {
                        m_AppendStates.emplace(nullptr, ST_STRUCTURE, CURRENT_APPEND_STATE.m_Choice);
                        RetVal &= InternalAppend(Value);
                        break;
                    }
                    else if ((COSEMDataType::ARRAY == CURRENT_APPEND_STATE.m_Choice) &&     // Himanshu - added else-if block
                        COSEM_IS_ARRAY_BEGIN(CURRENT_APPEND_STATE.m_SchemaEntry))
                    {
                        m_AppendStates.emplace(nullptr, ST_ARRAY, CURRENT_APPEND_STATE.m_Choice);
                        RetVal &= InternalAppend(Value);
                        break;
                    }
                    else
                    {
                        RetVal &= InternalSimpleAppend(CURRENT_APPEND_STATE.m_SchemaEntry, Value);
                        CURRENT_APPEND_STATE.m_Choice = INVALID_CHOICE;
                        break;
                    }
                }
                break;
            // Himanshu - added all below this to the function.
            case ST_STRUCTURE:
                //
                // PRECONDITIONS
                //
                if (COSEMDataType::ANY_TYPE == COSEM_SCHEMA_DATA_TYPE(CURRENT_APPEND_STATE.m_SchemaEntry))
                {
                    InternalAnyAppend(Value);
                    CURRENT_APPEND_STATE.m_SequenceIndex = DLMSValueGetStructureSize(Value);    // To nullify next if condition
                    break;
                }
                if (-1 == CURRENT_APPEND_STATE.m_SequenceIndex)
                {
                    const DLMSStructure& Structure = DLMSValueGetStructure(Value);
                    ssize_t ExpectedElements = StructureElementCount(CURRENT_APPEND_STATE.m_SchemaEntry);
                    if (Structure.size() == ExpectedElements)
                    {
                        m_Data.Append<uint8_t>(COSEMDataType::STRUCTURE);
                        ASNType::AppendLength(Structure.size(), &m_Data);
                        CURRENT_APPEND_STATE.m_SequenceIndex = 0;
                    }
                    else
                    {
                        return false;
                    }
                }
                if (COSEM_IS_STRUCTURE_END(CURRENT_APPEND_STATE.m_SchemaEntry))
                {
                    m_AppendStates.pop();
                    return RetVal;
                }
                else if (BEGIN_CHOICE_T == COSEM_SCHEMA_INTERNAL_DATA_TYPE(CURRENT_APPEND_STATE.m_SchemaEntry))
                {
                    const DLMSValue& Element = DLMSValueGetStructure(Value)[CURRENT_APPEND_STATE.m_SequenceIndex++];
                    m_AppendStates.emplace(nullptr, ST_CHOICE, CURRENT_APPEND_STATE.m_Choice);
                    RetVal &= InternalAppend(Element);
                    break;
                }
                else if (COSEM_IS_STRUCTURE_BEGIN(CURRENT_APPEND_STATE.m_SchemaEntry))
                {
                    const DLMSValue& Element = DLMSValueGetStructure(Value)[CURRENT_APPEND_STATE.m_SequenceIndex++];
                    m_AppendStates.emplace(nullptr, ST_STRUCTURE, CURRENT_APPEND_STATE.m_Choice);
                    RetVal &= InternalAppend(Element);
                    break;
                }
                else if (COSEM_IS_ARRAY_BEGIN(CURRENT_APPEND_STATE.m_SchemaEntry))
                {
                    const DLMSValue& Element = DLMSValueGetStructure(Value)[CURRENT_APPEND_STATE.m_SequenceIndex++];
                    m_AppendStates.emplace(nullptr, ST_ARRAY, CURRENT_APPEND_STATE.m_Choice);
                    RetVal &= InternalAppend(Element);
                    break;
                }
                else
                {
                    const DLMSValue& Element = DLMSValueGetStructure(Value)[CURRENT_APPEND_STATE.m_SequenceIndex++];
                    RetVal &= InternalSimpleAppend(CURRENT_APPEND_STATE.m_SchemaEntry, Element);
                    break;
                }
                return false;
            case ST_ARRAY:          // Himanshu - added new case
                //
                // PRECONDITIONS
                //
                if (COSEMDataType::ANY_TYPE == COSEM_SCHEMA_DATA_TYPE(CURRENT_APPEND_STATE.m_SchemaEntry))
                {
                    InternalAnyAppend(Value);
                    CURRENT_APPEND_STATE.m_SequenceIndex = DLMSValueGetArraySize(Value);        // To nullify next if condition
                    break;
                }
                if (-1 == CURRENT_APPEND_STATE.m_SequenceIndex)
                {
                    const DLMSArray& Array = DLMSValueGetArray(Value);
                    m_Data.Append<uint8_t>(COSEMDataType::ARRAY);
                    ASNType::AppendLength(Array.size(), &m_Data);
                    CURRENT_APPEND_STATE.m_SequenceIndex = Array.size();
                }
                if (COSEM_IS_ARRAY_END(CURRENT_APPEND_STATE.m_SchemaEntry))
                {
                    if (IsArray(Value) and CURRENT_APPEND_STATE.m_SequenceIndex != 0)
                        printf("Should Repeat??\r\n");
                    m_AppendStates.pop();
                    return RetVal;
                }
                else
                {
                    const DLMSArray& Array = DLMSValueGetArray(Value);
                    SchemaEntryPtr pCurrentSchema = m_pCurrentSchema;
                    for(const DLMSValue& InternalValue : Array)
                    {
                        m_pCurrentSchema = pCurrentSchema;
                        CURRENT_APPEND_STATE.m_SequenceIndex--;
                        if (COSEM_IS_BEGINNING(CURRENT_APPEND_STATE.m_SchemaEntry)) {
                            if (COSEM_IS_STRUCTURE_BEGIN(CURRENT_APPEND_STATE.m_SchemaEntry))
                                m_AppendStates.emplace(pCurrentSchema, ST_STRUCTURE, CURRENT_APPEND_STATE.m_Choice);
                            else if (COSEM_IS_ARRAY_BEGIN(CURRENT_APPEND_STATE.m_SchemaEntry))
                                m_AppendStates.emplace(pCurrentSchema, ST_ARRAY, CURRENT_APPEND_STATE.m_Choice);
                            else
                                m_AppendStates.emplace(pCurrentSchema, ST_CHOICE, CURRENT_APPEND_STATE.m_Choice);
                            RetVal &= InternalAppend(InternalValue);
                        }
                        else {
                            RetVal &= InternalSimpleAppend(CURRENT_APPEND_STATE.m_SchemaEntry, InternalValue);
                        }
                    }
                    break;
                }
                return false;
            default:
                LOG_ERROR("Default!!\r\n");
                return false;
            }
        }
        return false;
    }

    bool COSEMType::InternalAppend(const DLMSVector& Value)
    {
        return m_Data.Append(Value) >= 0;
    }
    //
    // COSEMBitString
    //
    COSEMBitString::COSEMBitString()
        : COSEMType(BIT_STRING)
    {
    }

    COSEMBitString::~COSEMBitString()
    {
    }

    COSEMBitString::COSEMBitString(size_t BitsExpected)
        : COSEMType(BIT_STRING), m_BitsExpected(BitsExpected)
    {
        if (0 == BitsExpected)
        {
            throw std::invalid_argument("BitsExpected must be > 0");
        }
    }

    size_t COSEMBitString::GetBitLength() const
    {
        return m_BitsExpected;
    }

    COSEMBitString::COSEMBitString(size_t BitsExpected, const DLMSBitSet& Value)
        : COSEMType(BIT_STRING), m_BitsExpected(BitsExpected)
    {
        if (0 == BitsExpected)
        {
            throw std::invalid_argument("BitsExpected must be > 0");
        }
        uint8_t ByteLength = BitsExpected / 8;
        uint8_t ValueBitIndex = 0;
        if (BitsExpected % 8)
        {
            ++ByteLength;
        }
        ASNType::AppendLength(BitsExpected, &m_Data);
        size_t Offset = m_Data.AppendExtra(ByteLength);
        for (uint8_t ByteIndex = Offset + ByteLength - 1;
             ByteIndex >= Offset; --ByteIndex)
        {
            uint8_t CurrentByte = 0;
            for (int BitShift = 0; BitShift < 8; BitShift++)
            {
                CurrentByte |= (Value[ValueBitIndex++] << BitShift);
            }
            m_Data[ByteIndex] = CurrentByte;
        }

    }

    COSEMBitString::operator DLMSValue() const
    {
        return m_Data;
    }

    bool COSEMBitString::Peek(SchemaEntryPtr SchemaEntry, const COSEMType& Value, DLMSValue * pVariant, size_t * pBytes /* = nullptr */)
    {
        DLMSVector Output;
        size_t     Offset = Value.m_Data.GetReadPosition();
        size_t     Length = 0;
        size_t     LengthBytes = 0;

        if (ASNType::PeekLength(Value.m_Data, 0, &Length, &LengthBytes))
        {
            Offset += LengthBytes;
            LengthBytes += (Length / 8);
            if (Length % 8)
            {
                ++LengthBytes;
            }
        }
        else
        {
            return false;
        }
        if (LengthBytes > Value.m_Data.Size())
        {
            return false;
        }
        if (pBytes)
        {
            *pBytes = LengthBytes;
        }
        DLMSBitSet Bitset;
        for (ssize_t BitIndex = Length - 1; BitIndex >=0; --BitIndex)
        {
            Bitset[BitIndex] = Value.m_Data[Offset] &
                                    (1 << (BitIndex % 8));
            if (BitIndex % 8 == 0)
            {
                ++Offset;
            }
        }
        *pVariant = Bitset;
        return true;
    }

    bool COSEMBitString::Get(SchemaEntryPtr SchemaEntry, COSEMType * pValue, DLMSValue * pVariant)
    {
        size_t Bytes = 0;
        if (Peek(SchemaEntry, *pValue, pVariant, &Bytes))
        {
            pValue->m_Data.Skip(Bytes);
            return true;
        }
        return false;

    }

    // Himanshu
    bool COSEMTypeGetVisitor::GetNextValue(DLMSValue * pValue)
    {
        if (m_Data.Size() == 0)
        {
            return false;
        }
        if (m_Data.IsAtEnd())
        {
            return false;
        }
        COSEMDataType DT = COSEMDataType(m_Data.Get<uint8_t>());
        switch (DT)
        {
        case NULL_DATA:
            pValue->set<blank>();
            return true;
        case ARRAY:
            {
                size_t     Length = 0;
                DLMSArray Array;
                if (ASNType::GetLength(&m_Data, &Length))
                {
                    for (size_t Index = 0; Index < Length; ++Index)
                    {
                        DLMSValue Value;
                        if (GetNextValue(&Value))
                        {
                            Array.push_back(Value);
                        }
                        else
                        {
                            return false;
                        }
                    }
                    *pValue = Array;
                    return true;
                }
            }
            break;
        case STRUCTURE:
            {
                size_t      Length = 0;
                DLMSStructure Structure;
                if (ASNType::GetLength(&m_Data, &Length))
                {
                    for (size_t Index = 0; Index < Length; ++Index)
                    {
                        DLMSValue Value;
                        if (GetNextValue(&Value))
                        {
                            Structure.push_back(Value);
                        }
                        else
                        {
                            return false;
                        }
                    }
                    *pValue = Structure;
                    return true;
                }
            }
            break;
        case BOOLEAN:
            return m_Data.Get<bool>(pValue);
        case BIT_STRING:
            {
                size_t     Length = 0;
                DLMSBitSet Bitset;
                if (ASNType::GetLength(&m_Data, &Length))
                {
                    for (size_t BitIndex = 0; BitIndex < Length; ++BitIndex)
                    {
                        Bitset[BitIndex] = m_Data.Get<uint8_t>() & (1 << (BitIndex % 8));
                    }
                    *pValue = Bitset;
                    return true;
                }
            }
            break;
        case DOUBLE_LONG:
            return m_Data.Get<int32_t>(pValue);
        case DOUBLE_LONG_UNSIGNED:
            return m_Data.Get<uint32_t>(pValue);
        case OCTET_STRING:
            {
                size_t     Length = 0;
                DLMSVector Vector;
                if (ASNType::GetLength(&m_Data, &Length) &&
                    m_Data.GetVector(&Vector, Length))
                {
                    *pValue = Vector;
                    return true;
                }
            }
            break;
        case VISIBLE_STRING:
            {
                size_t      Length = 0;
                std::string String;
                if (ASNType::GetLength(&m_Data, &Length) &&
                    m_Data.Get(&String, Length))
                {
                    *pValue = String;
                    return true;
                }
            }
            break;
        case UTF8_STRING:
            LOG_ERROR("InternalSimpleGet: Type %x not implemented : UTF-8 string.\r\n", DT);
            break;
        case INTEGER:
            return m_Data.Get<int8_t>(pValue);
        case ENUM:
        case UNSIGNED:
            return m_Data.Get<uint8_t>(pValue);
        case LONG:
            return m_Data.Get<int16_t>(pValue);
        case LONG_UNSIGNED:
            return m_Data.Get<uint16_t>(pValue);
        case LONG64:
            return m_Data.Get<int64_t>(pValue);
        case LONG64_UNSIGNED:
            return m_Data.Get<uint64_t>(pValue);
        case FLOATING_POINT:
        case FLOAT32:
            return m_Data.Get<float>(pValue);
        case FLOAT64:
            return m_Data.Get<double>(pValue);
        case BCD:
        case DATE_TIME:
        case DATE:
        case TIME:
        case DONT_CARE:
        default:
            LOG_ERROR("InternalSimpleGet: Type %x not implemented.\r\n", DT);
            // throw std::out_of_range("InternalSimpleGet: Type not implemented.");
        }
        return false;
    }

    // Himanshu
    DLMSVector COSEMTypeGetVisitor::GetNextValueBytes() {
        DLMSVector Bytes;
        if (m_Data.Size() == 0)
        {
            return Bytes;
        }
        if (m_Data.IsAtEnd())
        {
            return Bytes;
        }
        COSEMDataType DT = COSEMDataType(m_Data.Peek<uint8_t>());
        m_Data.GetVector(&Bytes, 1);
        switch (DT)
        {
        case NULL_DATA:
            break;
        case ARRAY:
        case STRUCTURE:
            {
                size_t Length = 0;
                size_t LengthBytes = m_Data.GetReadPosition();
                if (ASNType::GetLength(&m_Data, &Length))
                {
                    LengthBytes = m_Data.GetReadPosition() - LengthBytes;
                    m_Data.SetReadPosition(m_Data.GetReadPosition() - LengthBytes);
                    m_Data.GetVector(&Bytes, LengthBytes);
                    for (size_t Index = 0; Index < Length; ++Index)
                    {
                        DLMSVector Value = GetNextValueBytes();
                        Bytes.Append(Value);
                    }
                }
            }
            break;
        case BOOLEAN:
        case INTEGER:
        case ENUM:
        case UNSIGNED:
            m_Data.GetVector(&Bytes, 1);
            break;
        case LONG:
        case LONG_UNSIGNED:
            m_Data.GetVector(&Bytes, 2);
            break;
        case DOUBLE_LONG:
        case DOUBLE_LONG_UNSIGNED:
        case FLOATING_POINT:
        case FLOAT32:
            m_Data.GetVector(&Bytes, 4);
            break;
        case LONG64:
        case LONG64_UNSIGNED:
        case FLOAT64:
            m_Data.GetVector(&Bytes, 8);
            break;
        case BIT_STRING:
        case OCTET_STRING:
        case VISIBLE_STRING:
        case UTF8_STRING:
            {
                size_t     Length = 0;
                size_t LengthBytes = m_Data.GetReadPosition();
                if (ASNType::GetLength(&m_Data, &Length))
                {
                    LengthBytes = m_Data.GetReadPosition() - LengthBytes;
                    m_Data.SetReadPosition(m_Data.GetReadPosition() - LengthBytes);
                    m_Data.GetVector(&Bytes, LengthBytes + Length);
                }
            }
            break;
        case BCD:
        case DATE_TIME:
        case DATE:
        case TIME:
        case DONT_CARE:
        default:
            LOG_ERROR("InternalSimpleGet: Type %x not implemented.\r\n", DT);
            // throw std::out_of_range("InternalSimpleGet: Type not implemented.");
        }
        return Bytes;
    }

}
