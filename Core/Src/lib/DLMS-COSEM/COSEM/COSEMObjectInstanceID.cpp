// ===========================================================================
// Copyright (c) 2018, Electric Power Research Institute (EPRI)
// All rights reserved.
//
// DLMS-COSEM ("this software") is licensed under BSD 3-Clause license.
//
// Redistribution and use in source and binary forms, with or without modification,
// are permitted provided that the following conditions are met:
//
// *  Redistributions of source code must retain the above copyright notice, this
//    list of conditions and the following disclaimer.
//
// *  Redistributions in binary form must reproduce the above copyright notice,
//    this list of conditions and the following disclaimer in the documentation
//    and/or other materials provided with the distribution.
//
// *  Neither the name of EPRI nor the names of its contributors may
//    be used to endorse or promote products derived from this software without
//    specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
// IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
// INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
// WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
// OF SUCH DAMAGE.
//
// This EPRI software incorporates work covered by the following copyright and permission
// notices. You may not use these works except in compliance with their respective
// licenses, which are provided below.
//
// These works are provided by the copyright holders and contributors "as is" and any express or
// implied warranties, including, but not limited to, the implied warranties of merchantability
// and fitness for a particular purpose are disclaimed.
//
// This software relies on the following libraries and licenses:
//
// ###########################################################################
// Boost Software License, Version 1.0
// ###########################################################################
//
// * asio v1.10.8 (https://sourceforge.net/projects/asio/files/)
//
// Boost Software License - Version 1.0 - August 17th, 2003
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
//
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.
//

#include <cstring>
#include <algorithm>
#include <cassert>
#include <cstdio>

#include "COSEM/COSEMObjectInstanceID.h"

namespace EPRI
{
    //
    // COSEMObjectInstanceCriteria
    //
    COSEMObjectInstanceCriteria::COSEMObjectInstanceCriteria(const std::initializer_list<ValueGroupCriteria>& List)
    {
        assert(List.size() == COSEMValueGroupElements);

        ValueGroupCriteria * pCriteria = &m_Criteria[0];
        std::for_each(List.begin(),
            List.end(),
            [&pCriteria](const ValueGroupCriteria& Value)
            {
                *pCriteria++ = Value;
            });
    }

    COSEMObjectInstanceCriteria::COSEMObjectInstanceCriteria(const COSEMObjectInstanceID& OID)
    {
        for (uint8_t Group = COSEMObjectInstanceID::VALUE_GROUP_A;
             Group <= COSEMObjectInstanceID::VALUE_GROUP_F; ++Group)
        {
            m_Criteria[Group].Type = ValueGroupCriteria::TYPE_PRECISE;
            m_Criteria[Group].Value.ValueGroup = OID.GetValueGroup(COSEMObjectInstanceID::ValueGroup(Group));
        }
    }

    COSEMObjectInstanceCriteria::~COSEMObjectInstanceCriteria()
    {
    }

    bool COSEMObjectInstanceCriteria::Match(const COSEMObjectInstanceID& InstanceID) const
    {
        if (IsPrecise() and COSEMObjectInstanceID(*this).IsEmpty())
        {
            return true;
        }
        uint8_t Matches = 0;
        for (uint8_t Group = COSEMObjectInstanceID::VALUE_GROUP_A;
             Group <= COSEMObjectInstanceID::VALUE_GROUP_F; ++Group)
        {
            uint8_t ValueGroupValue = InstanceID.GetValueGroup(COSEMObjectInstanceID::ValueGroup(Group));
            if (m_Criteria[Group].Type == ValueGroupCriteria::TYPE_PRECISE &&
                (m_Criteria[Group].Value.ValueGroup == ANY ||
                 ValueGroupValue == m_Criteria[Group].Value.ValueGroup))
            {
                ++Matches;
            }
            else if ((m_Criteria[Group].Type == ValueGroupCriteria::TYPE_RANGE) &&
                     ((m_Criteria[Group].Value.ValueRange.Low == ANY &&
                       m_Criteria[Group].Value.ValueRange.High == ANY) ||
                      (m_Criteria[Group].Value.ValueRange.Low == ANY &&
                         ValueGroupValue <= m_Criteria[Group].Value.ValueRange.High) ||
                      (m_Criteria[Group].Value.ValueRange.High == ANY &&
                         ValueGroupValue >= m_Criteria[Group].Value.ValueRange.Low) ||
                      (ValueGroupValue <= m_Criteria[Group].Value.ValueRange.High &&
                         ValueGroupValue >= m_Criteria[Group].Value.ValueRange.Low)))
            {
                ++Matches;
            }
        }
        return Matches == COSEMValueGroupElements;
    }
    //
    // COSEMObjectInstanceID
    //
    COSEMObjectInstanceID::COSEMObjectInstanceID()
    {
    }

    COSEMObjectInstanceID::COSEMObjectInstanceID(const DLMSVector& Vector)
    {
        Vector.PeekBuffer(m_OBIS, sizeof(m_OBIS));
    }

    COSEMObjectInstanceID::COSEMObjectInstanceID(InstanceIDList List)
    {
        assert(List.size() == COSEMValueGroupElements);

        uint8_t * pOBIS = &m_OBIS[0];
        std::for_each(List.begin(),
            List.end(),
            [&pOBIS](InstanceIDList::value_type Value)
            {
                *pOBIS++ = Value;
            });
    }
    
    COSEMObjectInstanceID::COSEMObjectInstanceID(const COSEMObjectInstanceCriteria& Criteria)
    {
        if (not Criteria.IsPrecise())
        {
            throw std::invalid_argument("Criteria must be precise");
        }
        for (uint8_t Group = COSEMObjectInstanceID::VALUE_GROUP_A;
             Group <= COSEMObjectInstanceID::VALUE_GROUP_F; ++Group)
        {
            m_OBIS[Group] = Criteria.m_Criteria[Group].Value.ValueGroup;
        }
    }

    COSEMObjectInstanceID::~COSEMObjectInstanceID()
    {
    }

    bool COSEMObjectInstanceID::IsEmpty() const
    {
        for (size_t Index = 0; Index < sizeof(m_OBIS); ++Index)
        {
            if (m_OBIS[Index] != 0)
            {
                return false;
            }
        }
        return true;
    }

    bool COSEMObjectInstanceID::Parse(DLMSVector * pVector)
    {
        return pVector->GetBuffer(m_OBIS, sizeof(m_OBIS));
    }

    bool COSEMObjectInstanceID::Parse(const std::string& String)
    {
        bool RetVal =
            std::sscanf(String.c_str(),
                "%hhu%*[.-, :*]%hhu%*[.-, :*]%hhu%*[.-, :*]%hhu%*[.-, :*]%hhu%*[.-, :*]%hhu%*[.-, :*]",
                &m_OBIS[ValueGroup::VALUE_GROUP_A],
                &m_OBIS[ValueGroup::VALUE_GROUP_B],
                &m_OBIS[ValueGroup::VALUE_GROUP_C],
                &m_OBIS[ValueGroup::VALUE_GROUP_D],
                &m_OBIS[ValueGroup::VALUE_GROUP_E],
                &m_OBIS[ValueGroup::VALUE_GROUP_F]) == COSEMValueGroupElements;
        if (!RetVal)
        {
            std::memset(m_OBIS, '\0', sizeof(m_OBIS));
        }
        return RetVal;
    }

    std::string COSEMObjectInstanceID::ToString() const
    {
        char Buffer[30];
        std::snprintf(Buffer,
                      sizeof(Buffer),
                      "%u-%u:%u.%u.%u*%u",
                      GetValueGroup(ValueGroup::VALUE_GROUP_A),
                      GetValueGroup(ValueGroup::VALUE_GROUP_B),
                      GetValueGroup(ValueGroup::VALUE_GROUP_C),
                      GetValueGroup(ValueGroup::VALUE_GROUP_D),
                      GetValueGroup(ValueGroup::VALUE_GROUP_E),
                      GetValueGroup(ValueGroup::VALUE_GROUP_F));
        return std::string(Buffer);
    }

    bool COSEMObjectInstanceID::operator==(const COSEMObjectInstanceID& RHS) const
    {
        return std::memcmp(m_OBIS, RHS.m_OBIS, sizeof(m_OBIS)) == 0;
    }

    bool COSEMObjectInstanceID::operator!=(const COSEMObjectInstanceID& RHS) const
    {
        return std::memcmp(m_OBIS, RHS.m_OBIS, sizeof(m_OBIS)) != 0;
    }

    bool COSEMObjectInstanceID::operator<(const COSEMObjectInstanceID& RHS) const
    {
        //return std::memcmp(m_OBIS, RHS.m_OBIS, sizeof(m_OBIS)) < 0;
        for (size_t Index = 0; Index < sizeof(m_OBIS); ++Index)
        {
            if (m_OBIS[Index] < RHS.m_OBIS[Index])
            {
                return true;
            }
            else if (m_OBIS[Index] > RHS.m_OBIS[Index])
            {
                return false;
            }
        }
        return false;
    }

    COSEMObjectInstanceID::operator DLMSVector() const
    {
        DLMSVector RetVal;
        RetVal.AppendBuffer(m_OBIS, COSEMValueGroupElements);
        return RetVal;
    }

    COSEMObjectInstanceID::operator DLMSValue() const
    {
        return DLMSVector(*this);
    }

}