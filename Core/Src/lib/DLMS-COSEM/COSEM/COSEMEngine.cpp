// ===========================================================================
// Copyright (c) 2018, Electric Power Research Institute (EPRI)
// All rights reserved.
//
// DLMS-COSEM ("this software") is licensed under BSD 3-Clause license.
//
// Redistribution and use in source and binary forms, with or without modification,
// are permitted provided that the following conditions are met:
//
// *  Redistributions of source code must retain the above copyright notice, this
//    list of conditions and the following disclaimer.
//
// *  Redistributions in binary form must reproduce the above copyright notice,
//    this list of conditions and the following disclaimer in the documentation
//    and/or other materials provided with the distribution.
//
// *  Neither the name of EPRI nor the names of its contributors may
//    be used to endorse or promote products derived from this software without
//    specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
// IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
// INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
// WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
// OF SUCH DAMAGE.
//
// This EPRI software incorporates work covered by the following copyright and permission
// notices. You may not use these works except in compliance with their respective
// licenses, which are provided below.
//
// These works are provided by the copyright holders and contributors "as is" and any express or
// implied warranties, including, but not limited to, the implied warranties of merchantability
// and fitness for a particular purpose are disclaimed.
//
// This software relies on the following libraries and licenses:
//
// ###########################################################################
// Boost Software License, Version 1.0
// ###########################################################################
//
// * asio v1.10.8 (https://sourceforge.net/projects/asio/files/)
//
// Boost Software License - Version 1.0 - August 17th, 2003
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
//
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.
//

#include "ITemplates/IBaseLibrary.h"
#include "ITemplates/IDebug.h"
#include "COSEM/COSEMEngine.h"
#include "COSEM/COSEMDevice.h"
#include "wrapper/Transport.h"

namespace EPRI
{

#define MAKE_TOKEN(SERVICE, INVOKEID)\
    ((SERVICE << 24) | INVOKEID)            // Himanshu - ACCESS - changed from 8 to 24
    //
    // COSEMEngine
    //
    bool COSEMEngine::IsTransportConnected() const
    {
        return m_pTransport->IsConnected();
    }
    //
    // COSEMClientEngine
    //
    COSEMClientEngine::COSEMClientEngine(const Options& Opt, Transport * pXPort) :
        COSEMEngine(pXPort), m_Client(Opt.m_Address), m_Options(Opt)
    {
        m_Client.RegisterTransport(pXPort);
        m_Client.RegisterOpenConfirm(
            std::bind(&COSEMClientEngine::Client_OpenConfirmation, this, std::placeholders::_1));
        m_Client.RegisterGetConfirm(
            std::bind(&COSEMClientEngine::Client_GetConfirmation, this, std::placeholders::_1));
        m_Client.RegisterSetConfirm(
            std::bind(&COSEMClientEngine::Client_SetConfirmation, this, std::placeholders::_1));
        m_Client.RegisterActionConfirm(
            std::bind(&COSEMClientEngine::Client_ActionConfirmation, this, std::placeholders::_1));
        m_Client.RegisterReleaseConfirm(
            std::bind(&COSEMClientEngine::Client_ReleaseConfirmation, this, std::placeholders::_1));
        m_Client.RegisterAbortIndication(
            std::bind(&COSEMClientEngine::Client_AbortIndication, this, std::placeholders::_1));

        m_Client.RegisterAccessConfirm(
            std::bind(&COSEMClientEngine::Client_AccessConfirmation, this, std::placeholders::_1)); // Himanshu - ACCESS
    }

    COSEMClientEngine::~COSEMClientEngine()
    {
    }

    bool COSEMClientEngine::Process()
    {
        return true;
    }
    //
    // COSEM.Open Service
    //
    bool COSEMClientEngine::Open(COSEMAddressType DestinationAddress, const COSEMSecurityOptions& Security,
                                 const xDLMS::InitiateRequest& xDLMS)
    {
        return m_Client.OpenRequest(APPOpenRequestOrIndication(m_Options.m_Address, DestinationAddress,
                                                               xDLMS, Security));
    }

    bool COSEMClientEngine::OnOpenConfirmation(COSEMAddressType /*ServerAddress*/)
    {
        //
        // Default Handler Does Nothing
        //
        return true;
    }

    bool COSEMClientEngine::IsOpen() const
    {
        return m_Client.IsOpen();
    }
    //
    // COSEM.Get Service
    //
    bool COSEMClientEngine::Get(const Cosem_Attribute_Descriptor& Descriptor,
                                RequestToken * pToken)
    {
        bool                    RetVal = m_Client.IsOpen();
        if (RetVal)
        {
            RetVal = m_Client.GetRequest(
                           APPGetRequestOrIndication(m_Options.m_Address,
                                                     m_Client.GetAssociatedAddress(),
                                                     CurrentInvokeID(SERVICE_GET),
                                                     COSEMPriority::COSEM_PRIORITY_NORMAL,
                                                     COSEMServiceClass::COSEM_SERVICE_CONFIRMED,
                                                     Descriptor));

        }
        if (RetVal)
        {
            *pToken = MAKE_TOKEN(SERVICE_GET,
                                 GetAndIncrementInvokeID(SERVICE_GET));
            m_Responses.emplace(std::make_pair(*pToken, GetResponse(Descriptor)));
        }
        return RetVal;
    }

    bool COSEMClientEngine::OnGetConfirmation(RequestToken Token, const GetResponse& Response)
    {
        //
        // Default Handler Does Nothing
        //
        return true;
    }
    //
    // COSEM.Set Service
    //
    bool COSEMClientEngine::Set(const Cosem_Attribute_Descriptor& Descriptor,
                                const DLMSVector& Value,
                                RequestToken * pToken)
    {
        bool RetVal = m_Client.IsOpen();
        if (RetVal)
        {
            RetVal = m_Client.SetRequest(
                           APPSetRequestOrIndication(m_Options.m_Address,
                                m_Client.GetAssociatedAddress(),
                                CurrentInvokeID(SERVICE_SET),
                                COSEMPriority::COSEM_PRIORITY_NORMAL,
                                COSEMServiceClass::COSEM_SERVICE_CONFIRMED,
                                Descriptor,
                                Value));

        }
        if (RetVal)
        {
            *pToken = MAKE_TOKEN(SERVICE_SET,
                                 GetAndIncrementInvokeID(SERVICE_SET));
            m_Responses.emplace(std::make_pair(*pToken, SetResponse(Descriptor)));
        }
        return RetVal;
    }

    bool COSEMClientEngine::OnSetConfirmation(RequestToken Token, const SetResponse& Response)
    {
        //
        // Default Handler Does Nothing
        //
        return true;
    }
    //
    // COSEM.Action Service
    //
    bool COSEMClientEngine::Action(const Cosem_Method_Descriptor& Descriptor,
        const DLMSOptional<DLMSVector>& Parameters,
        RequestToken * pToken)
    {
        bool RetVal = m_Client.IsOpen();
        if (RetVal)
        {
            RetVal = m_Client.ActionRequest(
                           APPActionRequestOrIndication(m_Options.m_Address,
                                m_Client.GetAssociatedAddress(),
                                CurrentInvokeID(SERVICE_SET),
                                COSEMPriority::COSEM_PRIORITY_NORMAL,
                                COSEMServiceClass::COSEM_SERVICE_CONFIRMED,
                                Descriptor,
                                Parameters));

        }
        if (RetVal)
        {
            *pToken = MAKE_TOKEN(SERVICE_ACTION,
                                 GetAndIncrementInvokeID(SERVICE_ACTION));
            m_Responses.emplace(std::make_pair(*pToken, ActionResponse(Descriptor)));
        }
        return RetVal;
    }

    bool COSEMClientEngine::OnActionConfirmation(RequestToken Token, const ActionResponse& Response)
    {
        //
        // Default Handler Does Nothing
        //
        return true;
    }
    //
    // COSEM.Release Service
    //
    bool COSEMClientEngine::Release(const xDLMS::InitiateRequest& xDLMS, bool UseRLRE /* = true */)
    {
        if (m_Client.IsOpen())
        {
            m_Client.ReleaseRequest(
                APPReleaseRequestOrIndication(m_Options.m_Address,
                    m_Client.GetAssociatedAddress(),
                    xDLMS,
                    UseRLRE));
        }
        return true;
    }

    bool COSEMClientEngine::OnReleaseConfirmation(COSEMAddressType /*ServerAddress*/)
    {
        //
        // Default Handler Does Nothing
        //
        return true;
    }
    //
    // COSEM.Abort Service
    //
    bool COSEMClientEngine::OnAbortIndication(COSEMAddressType /*ServerAddress*/)
    {
        //
        // Default Handler Does Nothing
        //
        return true;
    }
    //
    // COSEM.Access Service - Himanshu - ACCESS
    //
    bool COSEMClientEngine::Access(const APPAccessRequestOrIndication::AccessRequestSpecs& Specs,
        const APPAccessRequestOrIndication::AccessRequestDatas& Datas,
        RequestToken * pToken)
    {
        if (m_Client.IsOpen())
        {
            bool RetVal = m_Client.AccessRequest(
                APPAccessRequestOrIndication(m_Options.m_Address,
                    m_Client.GetAssociatedAddress(),
                    CurrentLongInvokeID(),
                    COSEMPriority::COSEM_PRIORITY_NORMAL,
                    COSEMServiceClass::COSEM_SERVICE_CONFIRMED,
                    COSEMDateTime(false),
                    Specs,
                    Datas));
            if (RetVal)
            {
                *pToken = MAKE_TOKEN(SERVICE_ACCESS, GetAndIncrementLongInvokeID());
                m_Responses.emplace(std::make_pair(*pToken, AccessResponse(Specs)));
            }
            return RetVal;
        }
        return true;
    }

    bool COSEMClientEngine::OnAccessConfirmation(RequestToken Token, const AccessResponse& Response)
    {
        for (size_t i = 0; i < Response.m_AccessRequestSpecs.size(); i++)
        {
            if (Response.m_AccessResults[i].m_Result == APDUConstants::Data_Access_Result::success)
            {
                if (Response.m_AccessResults[i].m_Choice == Access_Response::access_response_get)
                {
                    GetResponse ResponseData(Response.m_AccessRequestSpecs[i].m_Descriptor);
                    if (Response.m_AccessResults[i].m_Result == APDUConstants::Data_Access_Result::success)
                        ResponseData.Result = Response.m_AccessDatas[i];
                    else
                        ResponseData.Result = Response.m_AccessResults[i].m_Result;
                    ResponseData.ResultValid = true;
                    OnGetConfirmation(Token, ResponseData);
                }
                else if (Response.m_AccessResults[i].m_Choice == Access_Response::access_response_set)
                {
                    SetResponse ResponseData(Response.m_AccessRequestSpecs[i].m_Descriptor);
                    ResponseData.Result = Response.m_AccessResults[i].m_Result;
                    ResponseData.ResultValid = true;
                    OnSetConfirmation(Token, ResponseData);
                }
                else if (Response.m_AccessResults[i].m_Choice == Access_Response::access_response_action)
                {
                    Cosem_Method_Descriptor Descriptor;
                    Descriptor.class_id = Response.m_AccessRequestSpecs[i].m_Descriptor.class_id;
                    Descriptor.instance_id = Response.m_AccessRequestSpecs[i].m_Descriptor.instance_id;
                    Descriptor.method_id = Response.m_AccessRequestSpecs[i].m_Descriptor.attribute_id;
                    ActionResponse ResponseData(Descriptor);
                    ResponseData.Result = (APDUConstants::Action_Result)Response.m_AccessResults[i].m_Result;
                    ResponseData.ResultValid = true;
                    OnActionConfirmation(Token, ResponseData);
                }
            }
        }
        return true;
    }
    //
    // Protected Methods
    //
    InvokeIdAndPriorityType COSEMClientEngine::CurrentInvokeID(ServiceID Service) const
    {
        return m_InvokeID[Service];
    }

    InvokeIdAndPriorityType COSEMClientEngine::GetAndIncrementInvokeID(ServiceID Service)
    {
        return m_InvokeID[Service]++;
    }

    LongInvokeIdAndPriorityType COSEMClientEngine::CurrentLongInvokeID() const      // Himanshu - ACCESS
    {
        return m_LongInvokeID;
    }

    LongInvokeIdAndPriorityType COSEMClientEngine::GetAndIncrementLongInvokeID()    // Himanshu - ACCESS
    {
        LongInvokeIdAndPriorityType LongInvokeID = m_LongInvokeID;
        m_LongInvokeID = (++m_LongInvokeID) % ALLOWED_LONG_INVOCATION_IDS;
        return LongInvokeID;
    }

    bool COSEMClientEngine::Client_OpenConfirmation(const BaseCallbackParameter& Parameters)
    {
        const APPOpenConfirmOrResponse& Confirmation =
            dynamic_cast<const APPOpenConfirmOrResponse&>(Parameters);
        return OnOpenConfirmation(Confirmation.m_SourceAddress);
    }

    bool COSEMClientEngine::Client_GetConfirmation(const BaseCallbackParameter& Parameters)
    {
        const APPGetConfirmOrResponse& Confirmation = dynamic_cast<const APPGetConfirmOrResponse&>(Parameters);
        RequestToken                   Token = MAKE_TOKEN(SERVICE_GET,
                                                          COSEM_GET_INVOKE_ID(Confirmation.m_InvokeIDAndPriority));
        try
        {
            GetResponse& Response = PickupResponse<GetResponse>(Token);
            Response.Result = Confirmation.m_Result;
            Response.ResultValid = true;

            return OnGetConfirmation(Token, Response);
        }
        catch (...)
        {
        }
        return false;
    }

    bool COSEMClientEngine::Client_SetConfirmation(const BaseCallbackParameter& Parameters)
    {
        const APPSetConfirmOrResponse& Confirmation = dynamic_cast<const APPSetConfirmOrResponse&>(Parameters);
        RequestToken                   Token = MAKE_TOKEN(SERVICE_SET,
                                                          COSEM_GET_INVOKE_ID(Confirmation.m_InvokeIDAndPriority));
        try
        {
            SetResponse& Response = PickupResponse<SetResponse>(Token);
            Response.Result = Confirmation.m_Result;
            Response.ResultValid = true;

            return OnSetConfirmation(Token, Response);
        }
        catch (...)
        {
        }
        return false;
    }

    bool COSEMClientEngine::Client_ActionConfirmation(const BaseCallbackParameter& Parameters)
    {
        const APPActionConfirmOrResponse& Confirmation = dynamic_cast<const APPActionConfirmOrResponse&>(Parameters);
        RequestToken                   Token = MAKE_TOKEN(SERVICE_ACTION,
                                                          COSEM_GET_INVOKE_ID(Confirmation.m_InvokeIDAndPriority));
        try
        {
            ActionResponse& Response = PickupResponse<ActionResponse>(Token);
            Response.Result = Confirmation.m_Result;
            Response.ResultValid = true;

            return OnActionConfirmation(Token, Response);
        }
        catch (...)
        {
        }
        return false;

    }

    bool COSEMClientEngine::Client_ReleaseConfirmation(const BaseCallbackParameter& Parameters)
    {
        const APPReleaseConfirmOrResponse& Confirmation = dynamic_cast<const APPReleaseConfirmOrResponse&>(Parameters);
        return OnReleaseConfirmation(Confirmation.m_SourceAddress);
    }

    bool COSEMClientEngine::Client_AbortIndication(const BaseCallbackParameter& Parameters)
    {
        const APPAbortIndication& Indication = dynamic_cast<const APPAbortIndication&>(Parameters);
        return OnAbortIndication(Indication.m_SourceAddress);
    }

    // Himanshu - ACCESS
    bool COSEMClientEngine::Client_AccessConfirmation(const BaseCallbackParameter& Parameters)
    {
        const APPAccessConfirmOrResponse& Confirmation = dynamic_cast<const APPAccessConfirmOrResponse&>(Parameters);
        RequestToken                   Token = MAKE_TOKEN(SERVICE_ACCESS,
                                                          COSEM_GET_INVOKE_ID_FROM_LONG(Confirmation.m_LongInvokeIDAndPriority));
        try
        {
            AccessResponse& Response = PickupResponse<AccessResponse>(Token);
            Response.m_DateTime      = Confirmation.m_DateTime;
            Response.m_AccessResults = Confirmation.m_AccessResults;
            Response.m_AccessDatas   = Confirmation.m_AccessDatas;
            Response.ResultValid = true;

            return OnAccessConfirmation(Token, Response);
        }
        catch (...)
        {
        }
        return false;

    }
    //
    // COSEMServerEngine
    //
    COSEMServerEngine::COSEMServerEngine(const Options& Opt, Transport * pXPort) :
        COSEMEngine(pXPort), m_Options(Opt)
    {
    }

    COSEMServerEngine::~COSEMServerEngine()
    {
    }

    bool COSEMServerEngine::Process()
    {
        return m_pTransport->Process();
    }

    void COSEMServerEngine::RegisterDevice(COSEMDevice * pDevice)
    {
        pDevice->RegisterTransport(m_pTransport);
        m_Devices.push_back(pDevice);
    }

    void COSEMServerEngine::UnregisterDevice(COSEMDevice * pDevice)
    {
        m_Devices.remove(pDevice);
    }

}