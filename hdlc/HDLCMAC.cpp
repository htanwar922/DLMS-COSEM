// ===========================================================================
// Copyright (c) 2018, Electric Power Research Institute (EPRI)
// All rights reserved.
//
// DLMS-COSEM ("this software") is licensed under BSD 3-Clause license.
//
// Redistribution and use in source and binary forms, with or without modification,
// are permitted provided that the following conditions are met:
//
// *  Redistributions of source code must retain the above copyright notice, this
//    list of conditions and the following disclaimer.
//
// *  Redistributions in binary form must reproduce the above copyright notice,
//    this list of conditions and the following disclaimer in the documentation
//    and/or other materials provided with the distribution.
//
// *  Neither the name of EPRI nor the names of its contributors may
//    be used to endorse or promote products derived from this software without
//    specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
// IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
// INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
// WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
// OF SUCH DAMAGE.
//
// This EPRI software incorporates work covered by the following copyright and permission
// notices. You may not use these works except in compliance with their respective
// licenses, which are provided below.
//
// These works are provided by the copyright holders and contributors "as is" and any express or
// implied warranties, including, but not limited to, the implied warranties of merchantability
// and fitness for a particular purpose are disclaimed.
//
// This software relies on the following libraries and licenses:
//
// ###########################################################################
// Boost Software License, Version 1.0
// ###########################################################################
//
// * asio v1.10.8 (https://sourceforge.net/projects/asio/files/)
//
// Boost Software License - Version 1.0 - August 17th, 2003
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
//
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.
// 

#include <algorithm>
#include <iostream>
#include <memory>

#include "ITemplates/ISerial.h"
#include "HDLCMAC.h"

namespace EPRI
{
    HDLCMAC::HDLCMAC(const HDLCAddress& MyAddress, 
        ISerialSocket * pSerial, 
        const HDLCOptions& Options,
        uint8_t MaxPreallocatedPacketBuffers) :
        m_MyAddress(MyAddress),
        m_pSerial(pSerial),
        m_CurrentOptions(Options),
        StateMachine(ST_MAX_STATES)
    {
        //
        // State Machine
        //
        BEGIN_STATE_MAP
            STATE_MAP_ENTRY(ST_DISCONNECTED, HDLCMAC::ST_Disconnected_Handler)
            STATE_MAP_ENTRY(ST_IEC_CONNECT, HDLCMAC::ST_IEC_Connect_Handler)
            STATE_MAP_ENTRY(ST_CONNECTING_WAIT, HDLCMAC::ST_Connecting_Wait_Handler)
            STATE_MAP_ENTRY(ST_CONNECTED, HDLCMAC::ST_Connected_Handler)
        END_STATE_MAP
        //
        while (MaxPreallocatedPacketBuffers--)
        {
            m_Packets.push(std::unique_ptr<Packet>(new Packet));
        }
        //
        // Physical Layer Handlers
        //
        m_pSerial->RegisterConnectHandler(
            std::bind(&HDLCMAC::Serial_Connect, this, std::placeholders::_1));
        m_pSerial->RegisterReadHandler(
            std::bind(&HDLCMAC::Serial_Receive, this, std::placeholders::_1, std::placeholders::_2));
        pSerial->RegisterCloseHandler(
            std::bind(&HDLCMAC::Serial_Close, this, std::placeholders::_1));
        //
        // Packet Handlers
        //
        m_PacketCallback.RegisterCallback(HDLCControl::INFO, 
            std::bind(&HDLCMAC::I_Handler, this, std::placeholders::_1));
    }
    
    HDLCMAC::~HDLCMAC()
    {
    }
    
    HDLCAddress HDLCMAC::MyAddress() const
    {
        return m_MyAddress;
    }
    
    HDLCAddress HDLCMAC::ConnectedAddress() const
    {
        return m_ConnectedAddress;
    }

    const HDLCStatistics& HDLCMAC::Statistics() const
    {
        return m_Statistics;
    }
    void HDLCMAC::ClearStatistics()
    {
        m_Statistics.Clear();
    }
    
    bool HDLCMAC::IsConnected() const
    {
        return m_CurrentState == ST_CONNECTED;
    }   
    //
    // DL-SET_VALUE
    //
    void HDLCMAC::SetOptions(const HDLCOptions& Options)
    {
        m_CurrentOptions = Options;
    }
    //
    // DL-GET_VALUE
    //
    HDLCOptions HDLCMAC::GetOptions() const
    {
        return m_CurrentOptions;
    }
    //
    // DA-DATA Service Implementation
    //
    bool HDLCMAC::DataRequest(const DLDataRequestParameter& Parameters)
    {
        bool bAllowed = false;
        BEGIN_TRANSITION_MAP
            TRANSITION_MAP_ENTRY(ST_DISCONNECTED, EVENT_IGNORED)
            TRANSITION_MAP_ENTRY(ST_IEC_CONNECT, EVENT_IGNORED)
            TRANSITION_MAP_ENTRY(ST_CONNECTING_WAIT, EVENT_IGNORED)
            TRANSITION_MAP_ENTRY(ST_CONNECTED, ST_CONNECTED)
        END_TRANSITION_MAP(bAllowed, new DataEventData(Parameters));
        return bAllowed;
    }
    
    void HDLCMAC::ST_Connected_Handler(EventData * pData)
    {
        //
        // Data Request
        //
        DataEventData * pDataEvent = dynamic_cast<DataEventData *>(pData);
        if (pDataEvent)
        {
            Packet *           pInfo = GetWorkingTXPacket();
            if (pInfo)
            {
                HDLCErrorCode ReturnCode = pInfo->MakePacket(Packet::NO_SEGMENT,
                    pDataEvent->Data.DestinationAddress,
                    m_MyAddress,
                    HDLCControl(HDLCControl::INFO),
                    pDataEvent->Data.Data.GetData(),
                    pDataEvent->Data.Data.Size());
                if (SUCCESS == ReturnCode)
                {
                    EnqueueWorkingTXPacket();
                }
                else
                {
                    ReleaseWorkingTXPacket();
                }
            }
            Process();
            return;
        }
        //
        // I Packet
        //
        PacketEventData * pPacketData = dynamic_cast<PacketEventData *>(pData);
        if (pPacketData && pPacketData->Data.GetControl().PacketType() == HDLCControl::INFO)
        {
            bool            RetVal = false;
            size_t          InfoLength = 0;
            const uint8_t * pInformation = pPacketData->Data.GetInformation(InfoLength);
            
            FireCallback(DLDataRequestParameter::ID, 
                DLDataRequestParameter(pPacketData->Data.GetSourceAddress(),
                    HDLCControl::INFO,
                    DLMSVector(pInformation, InfoLength)),
                &RetVal);
            
            Process();
            return;
        }        
    }    
    //
    // Packet Handlers
    //
    bool HDLCMAC::I_Handler(const Packet& RXPacket)
    {
        bool bAllowed = false;
        BEGIN_TRANSITION_MAP
            TRANSITION_MAP_ENTRY(ST_DISCONNECTED, EVENT_IGNORED)
            TRANSITION_MAP_ENTRY(ST_IEC_CONNECT, EVENT_IGNORED)
            TRANSITION_MAP_ENTRY(ST_CONNECTING_WAIT, EVENT_IGNORED)
            TRANSITION_MAP_ENTRY(ST_CONNECTED, ST_CONNECTED)
        END_TRANSITION_MAP(bAllowed, new PacketEventData(RXPacket));
        return bAllowed;
    }

    void HDLCMAC::LockPackets()
    {
        while (m_PacketLock.test_and_set())
            ;
    }
    
    void HDLCMAC::UnlockPackets()
    {
        m_PacketLock.clear();
    }
    
    Packet * HDLCMAC::GetWorkingRXPacket()
    {
        LockPackets();
        if (!m_pRXPacket)
        {
            if (m_Packets.size())
            {
                m_pRXPacket = std::move(m_Packets.front());
                m_Packets.pop();
            }
        }
        UnlockPackets();
        return m_pRXPacket.get();
    }
    
    void HDLCMAC::ReleaseWorkingRXPacket()
    {
        LockPackets();
        if (m_pRXPacket)
        {
            m_pRXPacket->Clear();
            m_Packets.push(std::move(m_pRXPacket));
        }
        UnlockPackets();
    }
    
    void HDLCMAC::EnqueueWorkingRXPacket()        
    {
        LockPackets();
        if (m_pRXPacket)
        {
            m_RXPackets.push(std::move(m_pRXPacket));
        }
        UnlockPackets();
    }

    HDLCErrorCode HDLCMAC::ProcessSerialReception(ERROR_TYPE Error, size_t BytesReceived)
    {
        HDLCErrorCode  ReturnValue = NEED_MORE;
        
        if (ERR_TIMEOUT == Error && !BytesReceived)
        {
            ReleaseWorkingRXPacket();
            m_RXVector.Clear();
            ArmAsyncRead();
        }
        else if (m_pSerial->AppendAsyncReadResult(&m_RXVector, BytesReceived))
        {
            Packet * pPacket = GetWorkingRXPacket();
            if (pPacket)
            {
                ReturnValue = pPacket->MakeByVector(&m_RXVector);
                if (SUCCESS == ReturnValue)
                {
                    EnqueueWorkingRXPacket(); 
                    ProcessPacketReception();
                    m_RXVector.Clear();
                    ArmAsyncRead();
                }
                else if (NEED_MORE == ReturnValue)
                {
                    ArmAsyncRead(m_CurrentOptions.InterOctetTimeoutInMs);
                }
                else
                {
                    //
                    // Parsing Error.  Try to flush and resync.
                    //
                    ReleaseWorkingRXPacket();
                    m_RXVector.Clear();
                    m_pSerial->Flush(EPRI::ISerialSocket::RECEIVE);
                    ArmAsyncRead();
                }          
            }
        }
        return ReturnValue;
    }

    Packet * HDLCMAC::GetWorkingTXPacket()
    {
        LockPackets();
        if (!m_pTXPacket)
        {
            if (m_Packets.size())
            {
                m_pTXPacket = std::move(m_Packets.front());
                m_Packets.pop();
            }
        }
        UnlockPackets();
        return m_pTXPacket.get();
    }
    
    void HDLCMAC::ReleaseWorkingTXPacket()
    {
        LockPackets();
        if (m_pTXPacket)
        {
            m_pTXPacket->Clear();
            m_Packets.push(std::move(m_pTXPacket));
        }
        UnlockPackets();
    }
    
    void HDLCMAC::EnqueueWorkingTXPacket()        
    {
        LockPackets();
        if (m_pTXPacket)
        {
            m_TXPackets.push(std::move(m_pTXPacket));
        }
        UnlockPackets();
    }

    Packet * HDLCMAC::GetOutgoingPacket()        
    {
        Packet * pRetVal = nullptr;
        LockPackets();
        if (m_TXPackets.size())
        {
            pRetVal = m_TXPackets.front().get();
        }
        UnlockPackets();
        return pRetVal;
    }

    void HDLCMAC::ReleaseOutgoingPacket()
    {
        LockPackets();
        if (m_TXPackets.size())
        {
            m_Packets.push(std::move(m_TXPackets.front()));
            m_TXPackets.pop();
        }
        UnlockPackets();
    }

    void HDLCMAC::ProcessSerialTransmission()
    {
        Packet *       pTXPacket = GetOutgoingPacket();
        if (pTXPacket)
        {
            if (m_pSerial->Write(*pTXPacket) != SUCCESSFUL) 
            {
                //
                // RETRY - STILL IN TX QUEUE
                //
            }
            ReleaseOutgoingPacket();
        }
    }

    Packet * HDLCMAC::GetIncomingPacket()
    {
        Packet * pRetVal = nullptr;
        LockPackets();
        if (m_RXPackets.size())
        {
            pRetVal = m_RXPackets.front().get();
        }
        UnlockPackets();
        return pRetVal;
    }
    
    void HDLCMAC::ReleaseIncomingPacket()
    {
        LockPackets();
        if (m_RXPackets.size())
        {
            m_Packets.push(std::move(m_RXPackets.front()));
            m_RXPackets.pop();
        }
        UnlockPackets();
    }

    HDLCErrorCode HDLCMAC::ProcessPacketReception()
    {
        HDLCErrorCode  ReturnValue = NEED_MORE;
        Packet *       pRXPacket = GetIncomingPacket();
        if (pRXPacket)
        {
            HDLCControl::Control PacketType = pRXPacket->GetControl().PacketType();
            if (pRXPacket->IsIdentify() ||
                pRXPacket->GetDestinationAddress() == m_MyAddress)
            {
                bool CallbackRetVal = false;
                if (m_PacketCallback.FireCallback(PacketType, *pRXPacket, &CallbackRetVal) && !CallbackRetVal)
                {
                    ReturnValue = FAIL;
                }
                else
                {
                    ReturnValue = SUCCESS;
                }
            }
            ReleaseIncomingPacket();
        }
        return ReturnValue;
    }
    
    bool HDLCMAC::ArmAsyncRead(uint32_t TimeOutInMs /*= 0*/, size_t MinimumSize /* = sizeof(uint8_t) */)
    {
        return SUCCESSFUL == m_pSerial->Read(nullptr, MinimumSize, TimeOutInMs);
    }
    
    void HDLCMAC::Serial_Receive(ERROR_TYPE Error, size_t BytesReceived)
    {
        ProcessSerialReception(Error, BytesReceived);
    }
    
    void HDLCMAC::Serial_Connect(ERROR_TYPE Error)
    {
        if (!Error)
        {
            //
            // Arm read to catch a header at least
            //
            ArmAsyncRead();
        }
    }
    
    void HDLCMAC::Serial_Close(ERROR_TYPE Error)
    {
    }
    
} /* namespace EPRI */