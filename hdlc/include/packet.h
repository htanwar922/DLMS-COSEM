// ===========================================================================
// Copyright (c) 2018, Electric Power Research Institute (EPRI)
// All rights reserved.
//
// DLMS-COSEM ("this software") is licensed under BSD 3-Clause license.
//
// Redistribution and use in source and binary forms, with or without modification,
// are permitted provided that the following conditions are met:
//
// *  Redistributions of source code must retain the above copyright notice, this
//    list of conditions and the following disclaimer.
//
// *  Redistributions in binary form must reproduce the above copyright notice,
//    this list of conditions and the following disclaimer in the documentation
//    and/or other materials provided with the distribution.
//
// *  Neither the name of EPRI nor the names of its contributors may
//    be used to endorse or promote products derived from this software without
//    specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
// IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
// INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
// WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
// OF SUCH DAMAGE.
//
// This EPRI software incorporates work covered by the following copyright and permission
// notices. You may not use these works except in compliance with their respective
// licenses, which are provided below.
//
// These works are provided by the copyright holders and contributors "as is" and any express or
// implied warranties, including, but not limited to, the implied warranties of merchantability
// and fitness for a particular purpose are disclaimed.
//
// This software relies on the following libraries and licenses:
//
// ###########################################################################
// Boost Software License, Version 1.0
// ###########################################################################
//
// * asio v1.10.8 (https://sourceforge.net/projects/asio/files/)
//
// Boost Software License - Version 1.0 - August 17th, 2003
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
//
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.
// 

#pragma once

#include <cstdint>

#include "HDLCErrors.h"
#include "HDLCStatistics.h"
#include "linkdefs.h"
#include "HDLCControl.h"
#include "HDLCAddress.h"
#include "DLMSVector.h"

namespace EPRI
{
	class ISerial;
	
	class Packet
	{
	public:
    	static const uint8_t IDENTIFY_FLAG1 = ' ';
    	static const uint8_t IDENTIFY_FLAG2 = 'I';
    	static const uint8_t IDENTIFY_RESPONSE[];
    	static const uint8_t HDLC_START_FLAG = 0x7E;
		static const uint8_t HDLC_STOP_FLAG = 0x7E;
		static const uint8_t FRAME_FORMAT = sizeof(uint16_t);
    	static const uint8_t MAX_ADDRESS_FIELD = sizeof(uint16_t);
		static const uint8_t CONTROL_FIELD = sizeof(uint8_t);
		static const uint8_t HCS_FIELD = sizeof(uint16_t);
		static const uint8_t CRC_FIELD = sizeof(uint16_t);
		static const uint8_t FLAG_FIELDS = sizeof(HDLC_START_FLAG) + sizeof(HDLC_STOP_FLAG);
		static const size_t MAX_PACKET_SIZE = 60;
		static const size_t STATIC_HEADER_SIZE = (FRAME_FORMAT + CONTROL_FIELD + HCS_FIELD);
    	static const size_t MAX_HDLC_FRAME_SIZE = STATIC_HEADER_SIZE + (2 * MAX_ADDRESS_FIELD) + MAX_PACKET_SIZE + FLAG_FIELDS + CRC_FIELD;
    	static const size_t HEADER_START_SIZE = (sizeof(uint8_t) + FRAME_FORMAT);

		enum Segmentation : uint8_t
		{
			NO_SEGMENT = 0,
			SEGMENT    = 1
		};
		
    	Packet();
		virtual ~Packet()
		{
		}
    	
    	void Clear();
   	
    	virtual uint16_t GetPacketLength() const;
    	virtual uint16_t GetRemainingPacketLength() const;
    	virtual Segmentation GetSegmentation() const;
    	virtual HDLCAddress GetDestinationAddress() const;
    	virtual HDLCAddress GetSourceAddress() const;
    	virtual HDLCControl GetControl() const;
    	virtual uint16_t GetInformationLength() const;
    	virtual const uint8_t * GetInformation(size_t& InformationLength) const;
    	virtual bool IsIdentify() const;
    	
    	virtual HDLCErrorCode MakePacket(Segmentation Segmented,
        	const HDLCAddress& DestinationAddr,
        	const HDLCAddress& SourceAddress,
        	const HDLCControl& Control,
        	const uint8_t * Information = nullptr,
        	size_t InformationSize = 0);
    	virtual HDLCErrorCode MakeIdentifyPacket(const HDLCControl& Control,
        	uint8_t SuccessCode = 0x00,
        	uint8_t ProtocolID = 0x00,
        	uint8_t ProtocolVersion = 0x00,
        	uint8_t ProtocolRevision = 0x00);

    	virtual HDLCErrorCode MakeByByte(uint8_t Byte);
    	virtual HDLCErrorCode MakeByVector(DLMSVector * pVector);
    	
    	operator const uint8_t *() const;
    	//
    	// TODO - Rework to Base Packet on DLMSVector. Phase II.
    	//
    	operator DLMSVector() const;

	protected:
    	enum PACKET_RX_STATE
    	{
        	STATE_RX_NO_PACKET,
        	STATE_RX_FRAME_FORMAT,
        	STATE_RX_SOURCE_ADDRESS,
        	STATE_RX_DESTINATION_ADDRESS,
        	STATE_RX_CONTROL,
        	STATE_RX_HCS,
        	STATE_RX_INFORMATION,
        	STATE_RX_CRC,
        	STATE_RX_IDENTIFY
    	};

    	struct PacketMappingIndexes
    	{
        	int m_Format;
        	int m_DestinationAddress;
        	int m_SourceAddress;
        	int m_Control;
        	int m_Information;
    	}               m_PacketMappings = {};

    	uint16_t GetU16(int Index) const;
        uint16_t ComputeCRC(const uint8_t * Buffer, size_t Size, uint16_t CurrentCRC = PPPINITFCS16);
		uint16_t ComputeCRC(uint8_t Byte, uint16_t CurrentCRC = PPPINITFCS16);
    	void Insert(uint8_t Word, int& Index);
    	void Insert(uint16_t Value, int& Index, bool bBigEndian = true);
    	void Insert(const HDLCAddress& Value, int& Index);
    	void InsertFrameFormat(size_t HeaderSize, 
        	const HDLCControl& Control, 
        	size_t InformationSize, 
        	Segmentation Segment, 
        	int& Index);

    	static const uint16_t PPPINITFCS16 = 0xFFFF;
    	static const uint16_t PPPGOODFCS16 = (0xF0B8 ^ 0xFFFF);
        uint8_t			      m_Information[MAX_HDLC_FRAME_SIZE] = { }; 
    	int                   m_HeaderLength = 0;
    	PACKET_RX_STATE	      m_PacketState;
    	int                   m_PacketIndex;
    	int                   m_CurrentFieldBytes;
	};

}