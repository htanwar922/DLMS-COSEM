// ===========================================================================
// Copyright (c) 2018, Electric Power Research Institute (EPRI)
// All rights reserved.
//
// DLMS-COSEM ("this software") is licensed under BSD 3-Clause license.
//
// Redistribution and use in source and binary forms, with or without modification,
// are permitted provided that the following conditions are met:
//
// *  Redistributions of source code must retain the above copyright notice, this
//    list of conditions and the following disclaimer.
//
// *  Redistributions in binary form must reproduce the above copyright notice,
//    this list of conditions and the following disclaimer in the documentation
//    and/or other materials provided with the distribution.
//
// *  Neither the name of EPRI nor the names of its contributors may
//    be used to endorse or promote products derived from this software without
//    specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
// IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
// INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
// WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
// OF SUCH DAMAGE.
//
// This EPRI software incorporates work covered by the following copyright and permission
// notices. You may not use these works except in compliance with their respective
// licenses, which are provided below.
//
// These works are provided by the copyright holders and contributors "as is" and any express or
// implied warranties, including, but not limited to, the implied warranties of merchantability
// and fitness for a particular purpose are disclaimed.
//
// This software relies on the following libraries and licenses:
//
// ###########################################################################
// Boost Software License, Version 1.0
// ###########################################################################
//
// * asio v1.10.8 (https://sourceforge.net/projects/asio/files/)
//
// Boost Software License - Version 1.0 - August 17th, 2003
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
//
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.
// 

#pragma once

#include <cstdint>

namespace EPRI
{

	class HDLCControl
	{
	public:
		enum Control : uint8_t
		{
			INFO    = 0x00,
			RR      = 0x01,
			RNR     = 0x05,
			SNRM    = 0x83,
			DISC    = 0x43,
			UA      = 0x63,
			DM      = 0x0F,
			FRMR    = 0x87,
			UI      = 0x03,
			IDENT   = 0x20,
			IDENTR  = 0xFE,
			UNKNOWN = 0xFF
		};
    	
    	enum PollFinal : uint8_t
    	{
        	NOT_SET  = 0b00000000,
        	SET      = 0b00010000
    	};

    	HDLCControl() :
        	m_Value(UNKNOWN)
		{ 
		}
    	
		HDLCControl(uint8_t Value) :
        	m_Value(Value)
		{
		}
    	
    	HDLCControl(Control Ctrl, PollFinal PF = SET, uint8_t NR = 0, uint8_t NS = 0)
    	{
        	switch (Ctrl)
        	{
    		case INFO:
            	m_Value = Ctrl | ((NR & 0b00000111) << 5) | (PF) | (NS << 1);
            	break;
			case RR:
            	m_Value = Ctrl | ((NR & 0b00000111) << 5) | (PF);
            	break;
			case RNR:
            	m_Value = Ctrl | ((NR & 0b00000111) << 5) | (PF);
            	break;
			case SNRM:
			case DISC:
			case UA:
			case DM:
			case FRMR:
			case UI:
            	m_Value = Ctrl | (PF);
            	break;
        	case IDENT:
        	case IDENTR:
            	m_Value = Ctrl;
            	break;
        	default:
            	m_Value = UNKNOWN;
            	break;
        	}
    	}
    	
		inline uint8_t NR() const
		{ 
			return (uint8_t)((m_Value & 0b11100000) >> 5); 
		}
    	
		inline uint8_t NS() const
		{ 
			return (uint8_t)((m_Value & 0b00001110) >> 1); 
		}
    	
		inline bool PF() const
		{ 
			return (bool)(m_Value & 0b00010000); 
		}

		inline bool IsResponse(void) const
		{
			switch (PacketType())
			{
			case INFO:
			case RR:
			case RNR:
			case UA:
			case DM:
			case FRMR:
			case UI:
			case IDENTR:
                return (true); 
			default:
				return (false); 
			}
		}

		inline Control PacketType() const
		{
    		if (IDENT == m_Value || IDENTR == m_Value)
    		{
        		return (Control) m_Value;
    		}
			if (0x00 == (m_Value & 0x01))
			{
				return INFO;
			}
			switch (m_Value & 0x0F)
			{
			case RR:
				return RR;
			case RNR:
				return RNR;
			default:
				switch (m_Value & 0b11101111)
				{
				case SNRM:
				case DISC:
				case UA:
				case DM:
				case FRMR:
				case UI:
					return Control(m_Value & 0b11101111);
				}
			}
			return UNKNOWN;
		}

		inline uint8_t * operator &()
		{
			return (&m_Value);
		}
    	
    	inline operator uint8_t() const
    	{
        	return m_Value;
    	}
    	
    	const char * ToString() const
    	{
        	switch (PacketType())
        	{
        	case INFO:
            	return "INFO";
        	case RR:
            	return "RR";
        	case RNR:
            	return "RNR";
        	case SNRM:
            	return "SNRM";
        	case DISC:
            	return "DISC";
        	case UA:
            	return "UA";
        	case DM:
            	return "DM";
        	case FRMR:
            	return "FRMR";
        	case UI:
            	return "UI";
        	case IDENT:
            	return "IDENT";
        	case IDENTR:
            	return "IDENTR";
        	default:
            	return "UNKNOWN";
        	}
    	}

	private:
		uint8_t	  m_Value;

	};

}